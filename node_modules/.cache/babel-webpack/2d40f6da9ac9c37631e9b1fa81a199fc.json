{"ast":null,"code":"/**\r\n * CSV parser.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DataParser } from \"./DataParser\";\nimport * as $type from \"../utils/Type\";\nimport * as $array from \"../utils/Array\";\n/**\r\n * Define possible separators.\r\n */\nvar separators = [\",\", \";\", \"\\t\"];\n/**\r\n * A parser for CSV format.\r\n *\r\n * @important\r\n */\nvar CSVParser = /** @class */function (_super) {\n  __extends(CSVParser, _super);\n  function CSVParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Content-type suitable for CSV format.\r\n     */\n    _this.contentType = \"text/csv\";\n    /**\r\n     * Parser options.\r\n     *\r\n     * @see {@link ICSVOptions} for description of each option\r\n     */\n    _this.options = {\n      delimiter: \"\",\n      reverse: false,\n      skipRows: 0,\n      skipEmpty: true,\n      useColumnNames: false\n    };\n    return _this;\n  }\n  /**\r\n   * Tests if the format is CSV.\r\n   *\r\n   * @param data  Source data\r\n   * @return Is it CSV?\r\n   */\n  CSVParser.isCSV = function (data) {\n    return CSVParser.getDelimiterFromData(data) ? true : false;\n  };\n  /**\r\n   * Tries to determine a column separator.\r\n   *\r\n   * @param data  Source data\r\n   * @return Separator\r\n   */\n  CSVParser.getDelimiterFromData = function (data) {\n    // We're going to take first few lines of the CSV with different\n    // possible separators and check if it results in same number of columns.\n    // If it does, we're going to assume it's a CSV\n    var lines = data.split(\"\\n\");\n    var len = lines.length;\n    var separator;\n    $array.each(separators, function (sep) {\n      var columns = 0,\n        lineColums = 0;\n      // TODO replace with iterators\n      for (var i = 0; i < len; ++i) {\n        // Get number of columns in a line\n        columns = lines[i].split(sep).length;\n        if (columns > 1) {\n          // More than one column - possible candidate\n          if (lineColums === 0) {\n            // First line\n            lineColums = columns;\n          } else if (columns != lineColums) {\n            // Incorrect number of columns, give up on this separator\n            lineColums = 0;\n            break;\n          }\n        } else {\n          // Not this separator\n          // Not point in continuing\n          lineColums = 0;\n          break;\n        }\n      }\n      // Check if we have a winner\n      if (lineColums) {\n        separator = sep;\n      }\n    });\n    return separator;\n  };\n  /**\r\n   * Parses and returns data.\r\n   *\r\n   * @param data  Unparsed data\r\n   * @return Parsed data\r\n   */\n  CSVParser.prototype.parse = function (csv) {\n    // Check if we have delimiter set\n    if (!this.options.delimiter) {\n      this.options.delimiter = CSVParser.getDelimiterFromData(csv);\n    }\n    // Get CSV data as array\n    var data = this.CSVToArray(csv, this.options.delimiter);\n    // Do we need to cast some fields to numbers?\n    var empty = $type.hasValue(this.options.emptyAs);\n    var numbers = this.parsableNumbers;\n    var dates = this.parsableDates;\n    // Init resuling array\n    var res = [],\n      cols = [],\n      col,\n      i;\n    // Skip rows\n    for (i = 0; i < this.options.skipRows; i++) {\n      data.shift();\n    }\n    // First row holds column names?\n    if (this.options.useColumnNames) {\n      cols = data.shift();\n      // Normalize column names\n      for (var x = 0; x < cols.length; x++) {\n        // trim\n        col = $type.hasValue(cols[x]) ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n        // Check for empty\n        if (\"\" === col) {\n          col = \"col\" + x;\n        }\n        cols[x] = col;\n      }\n    }\n    // Iterate through the result set\n    var row;\n    while (true) {\n      row = this.options.reverse ? data.pop() : data.shift();\n      if (!row) {\n        break;\n      }\n      if (this.options.skipEmpty && row.length === 1 && row[0] === \"\") {\n        continue;\n      }\n      var dataPoint = {};\n      for (i = 0; i < row.length; i++) {\n        col = undefined === cols[i] ? \"col\" + i : cols[i];\n        dataPoint[col] = row[i] === \"\" ? this.options.emptyAs : row[i];\n        // Convert\n        if (empty) {\n          dataPoint[col] = this.maybeToEmpty(dataPoint[col]);\n        }\n        if (numbers) {\n          dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);\n        }\n        if (dates) {\n          dataPoint[col] = this.maybeToDate(col, dataPoint[col]);\n        }\n      }\n      res.push(dataPoint);\n    }\n    return res;\n  };\n  /**\r\n   * Converts CSV into array.\r\n   *\r\n   * The functionality of this function is taken from here:\r\n   * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\r\n   *\r\n   * @param data       Source data\r\n   * @param delimiter  Column delimiter\r\n   * @return Parsed array\r\n   */\n  CSVParser.prototype.CSVToArray = function (data, delimiter) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    delimiter = delimiter || ',';\n    // Create a regular expression to parse the CSV values.\n    var objPattern = new RegExp(\n    // Delimiters.\n    \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n    // Quoted fields.\n    \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n    // Standard fields.\n    \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\");\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    var arrData = [[]];\n    // Create an array to hold our individual pattern\n    // matching groups.\n    var arrMatches = null;\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    while (true) {\n      arrMatches = objPattern.exec(data);\n      if (!arrMatches) {\n        break;\n      }\n      // Get the delimiter that was found.\n      var strMatchedDelimiter = arrMatches[1];\n      // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n      if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push([]);\n      }\n      // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n      var strMatchedValue = void 0;\n      if (arrMatches[2]) {\n        // We found a quoted value. When we capture\n        // this value, unescape any double quotes.\n        strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n      } else {\n        // We found a non-quoted value.\n        strMatchedValue = arrMatches[3];\n      }\n      // Now that we have our value string, let's add\n      // it to the data array.\n      arrData[arrData.length - 1].push(strMatchedValue);\n    }\n    // Return the parsed data.\n    return arrData;\n  };\n  return CSVParser;\n}(DataParser);\nexport { CSVParser };\n//# sourceMappingURL=CSVParser.js.map","map":null,"metadata":{},"sourceType":"module"}
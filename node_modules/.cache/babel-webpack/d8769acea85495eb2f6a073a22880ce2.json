{"ast":null,"code":"import { __values } from \"tslib\";\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { memoBuilder } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nexport function fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n  var original = source[name];\n  var wrapped = replacementFactory(original);\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      markFunctionWrapped(wrapped, original);\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n  source[name] = wrapped;\n}\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nexport function addNonEnumerableProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n    value: value,\n    writable: true,\n    configurable: true\n  });\n}\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nexport function markFunctionWrapped(wrapped, original) {\n  var proto = original.prototype || {};\n  wrapped.prototype = original.prototype = proto;\n  addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n}\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\nexport function getOriginalFunction(func) {\n  return func.__sentry_original__;\n}\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object) {\n  return Object.keys(object).map(function (key) {\n    return encodeURIComponent(key) + \"=\" + encodeURIComponent(object[key]);\n  }).join('&');\n}\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\nfunction getWalkSource(value) {\n  if (isError(value)) {\n    var error = value;\n    var err = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    for (var i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n    return err;\n  }\n  if (isEvent(value)) {\n    var event_1 = value;\n    var source = {};\n    // Accessing event attributes can throw (see https://github.com/getsentry/sentry-javascript/issues/768 and\n    // https://github.com/getsentry/sentry-javascript/issues/838), but accessing `type` hasn't been wrapped in a\n    // try-catch in at least two years and no one's complained, so that's likely not an issue anymore\n    source.type = event_1.type;\n    try {\n      source.target = isElement(event_1.target) ? htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n    try {\n      source.currentTarget = isElement(event_1.currentTarget) ? htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event_1.detail;\n    }\n    for (var attr in event_1) {\n      if (Object.prototype.hasOwnProperty.call(event_1, attr)) {\n        source[attr] = event_1[attr];\n      }\n    }\n    return source;\n  }\n  return value;\n}\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n/** Calculates bytes size of input object */\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n/** JSDoc */\nexport function normalizeToSize(object,\n// Default Node.js REPL depth\ndepth,\n// 100kB, as 200kB is max payload size, so half sounds reasonable\nmaxSize) {\n  if (depth === void 0) {\n    depth = 3;\n  }\n  if (maxSize === void 0) {\n    maxSize = 100 * 1024;\n  }\n  var serialized = normalize(object, depth);\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n  return serialized;\n}\n/**\n * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,\n * booleans, null, and undefined.\n *\n * @param value The value to stringify\n * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or\n *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,\n *  unchanged.\n */\nfunction serializeValue(value) {\n  // Node.js REPL notation\n  if (typeof value === 'string') {\n    return value;\n  }\n  var type = Object.prototype.toString.call(value);\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n  var normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\nfunction normalizeValue(value, key) {\n  if (key === 'domain' && value && typeof value === 'object' && value._events) {\n    return '[Domain]';\n  }\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n  if (typeof global !== 'undefined' && value === global) {\n    return '[Global]';\n  }\n  // It's safe to use `window` and `document` here in this manner, as we are asserting using `typeof` first\n  // which won't throw if they are not present.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof window !== 'undefined' && value === window) {\n    return '[Window]';\n  }\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof document !== 'undefined' && value === document) {\n    return '[Document]';\n  }\n  // React's SyntheticEvent thingy\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n  if (value === void 0) {\n    return '[undefined]';\n  }\n  if (typeof value === 'function') {\n    return \"[Function: \" + getFunctionName(value) + \"]\";\n  }\n  // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable\n  if (typeof value === 'symbol') {\n    return \"[\" + String(value) + \"]\";\n  }\n  if (typeof value === 'bigint') {\n    return \"[BigInt: \" + String(value) + \"]\";\n  }\n  return value;\n}\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function walk(key, value, depth, memo) {\n  if (depth === void 0) {\n    depth = +Infinity;\n  }\n  if (memo === void 0) {\n    memo = memoBuilder();\n  }\n  // If we reach the maximum depth, serialize whatever is left\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  // If normalized value is a primitive, there are no branches left to walk, so bail out\n  var normalized = normalizeValue(value, key);\n  if (isPrimitive(normalized)) {\n    return normalized;\n  }\n  // Create source that we will use for the next iteration. It will either be an objectified error object (`Error` type\n  // with extracted key:value pairs) or the input itself.\n  var source = getWalkSource(value);\n  // Create an accumulator that will act as a parent for all future itterations of that branch\n  var acc = Array.isArray(value) ? [] : {};\n  // If we already walked that branch, bail out, as it's circular reference\n  if (memo[0](value)) {\n    return '[Circular ~]';\n  }\n  // Walk all keys of the source\n  for (var innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    }\n    // Recursively walk through all the child nodes\n    acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  }\n  // Once walked through all the branches, remove the parent from memo storage\n  memo[1](value);\n  // Return accumulated values\n  return acc;\n}\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function normalize(input, depth) {\n  try {\n    return JSON.parse(JSON.stringify(input, function (key, value) {\n      return walk(key, value, depth);\n    }));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception, maxLength) {\n  if (maxLength === void 0) {\n    maxLength = 40;\n  }\n  var keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n  return '';\n}\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys(val) {\n  var e_1, _a;\n  if (isPlainObject(val)) {\n    var obj = val;\n    var rv = {};\n    try {\n      for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        if (typeof obj[key] !== 'undefined') {\n          rv[key] = dropUndefinedKeys(obj[key]);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return rv;\n  }\n  if (Array.isArray(val)) {\n    return val.map(dropUndefinedKeys);\n  }\n  return val;\n}\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nexport function objectify(wat) {\n  var objectified;\n  switch (true) {\n    case wat === undefined || wat === null:\n      objectified = new String(wat);\n      break;\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new wat.constructor(wat);\n      break;\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n//# sourceMappingURL=object.js.map","map":null,"metadata":{},"sourceType":"module"}
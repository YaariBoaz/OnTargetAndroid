{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport { HttpErrorResponse } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport * as Sentry from '@sentry/browser';\nimport { runOutsideAngular } from './zone';\n/**\n * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.\n */\nvar SentryErrorHandler = /** @class */function () {\n  function SentryErrorHandler(options) {\n    this._options = __assign({\n      logErrors: true\n    }, options);\n  }\n  /**\n   * Method called for every value captured through the ErrorHandler\n   */\n  SentryErrorHandler.prototype.handleError = function (error) {\n    var extractedError = this._extractError(error) || 'Handled unknown error';\n    // Capture handled exception and send it to Sentry.\n    var eventId = runOutsideAngular(function () {\n      return Sentry.captureException(extractedError);\n    });\n    // When in development mode, log the error to console for immediate feedback.\n    if (this._options.logErrors) {\n      // eslint-disable-next-line no-console\n      console.error(extractedError);\n    }\n    // Optionally show user dialog to provide details on what happened.\n    if (this._options.showDialog) {\n      Sentry.showReportDialog(__assign(__assign({}, this._options.dialogOptions), {\n        eventId: eventId\n      }));\n    }\n  };\n  /**\n   * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.\n   */\n  SentryErrorHandler.prototype._extractError = function (error) {\n    // Allow custom overrides of extracting function\n    if (this._options.extractor) {\n      var defaultExtractor = this._defaultExtractor.bind(this);\n      return this._options.extractor(error, defaultExtractor);\n    }\n    return this._defaultExtractor(error);\n  };\n  /**\n   * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.\n   */\n  SentryErrorHandler.prototype._defaultExtractor = function (errorCandidate) {\n    var error = errorCandidate;\n    // Try to unwrap zone.js error.\n    // https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts\n    if (error && error.ngOriginalError) {\n      error = error.ngOriginalError;\n    }\n    // We can handle messages and Error objects directly.\n    if (typeof error === 'string' || error instanceof Error) {\n      return error;\n    }\n    // If it's http module error, extract as much information from it as we can.\n    if (error instanceof HttpErrorResponse) {\n      // The `error` property of http exception can be either an `Error` object, which we can use directly...\n      if (error.error instanceof Error) {\n        return error.error;\n      }\n      // ... or an`ErrorEvent`, which can provide us with the message but no stack...\n      if (error.error instanceof ErrorEvent && error.error.message) {\n        return error.error.message;\n      }\n      // ...or the request body itself, which we can use as a message instead.\n      if (typeof error.error === 'string') {\n        return \"Server returned code \" + error.status + \" with body \\\"\" + error.error + \"\\\"\";\n      }\n      // If we don't have any detailed information, fallback to the request message itself.\n      return error.message;\n    }\n    // Nothing was extracted, fallback to default error message.\n    return null;\n  };\n  SentryErrorHandler = __decorate([Injectable({\n    providedIn: 'root'\n  })], SentryErrorHandler);\n  return SentryErrorHandler;\n}();\n/**\n * Factory function that creates an instance of a preconfigured ErrorHandler provider.\n */\nfunction createErrorHandler(config) {\n  return new SentryErrorHandler(config);\n}\nexport { createErrorHandler, SentryErrorHandler };\n//# sourceMappingURL=errorhandler.js.map","map":null,"metadata":{},"sourceType":"module"}
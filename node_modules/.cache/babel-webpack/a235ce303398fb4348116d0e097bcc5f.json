{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { getEventDescription, isDebugBuild, isMatchingPattern, logger } from '@sentry/utils';\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nvar DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n/** Inbound filters configurable by the user */\nvar InboundFilters = /** @class */function () {\n  function InboundFilters(_options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n    this._options = _options;\n    /**\n     * @inheritDoc\n     */\n    this.name = InboundFilters.id;\n  }\n  /**\n   * @inheritDoc\n   */\n  InboundFilters.prototype.setupOnce = function () {\n    addGlobalEventProcessor(function (event) {\n      var hub = getCurrentHub();\n      if (!hub) {\n        return event;\n      }\n      var self = hub.getIntegration(InboundFilters);\n      if (self) {\n        var client = hub.getClient();\n        var clientOptions = client ? client.getOptions() : {};\n        // This checks prevents most of the occurrences of the bug linked below:\n        // https://github.com/getsentry/sentry-javascript/issues/2622\n        // The bug is caused by multiple SDK instances, where one is minified and one is using non-mangled code.\n        // Unfortunatelly we cannot fix it reliably (thus reserved property in rollup's terser config),\n        // as we cannot force people using multiple instances in their apps to sync SDK versions.\n        var options = typeof self._mergeOptions === 'function' ? self._mergeOptions(clientOptions) : {};\n        if (typeof self._shouldDropEvent !== 'function') {\n          return event;\n        }\n        return self._shouldDropEvent(event, options) ? null : event;\n      }\n      return event;\n    });\n  };\n  /** JSDoc */\n  InboundFilters.prototype._shouldDropEvent = function (event, options) {\n    if (this._isSentryError(event, options)) {\n      if (isDebugBuild()) {\n        logger.warn(\"Event dropped due to being internal Sentry Error.\\nEvent: \" + getEventDescription(event));\n      }\n      return true;\n    }\n    if (this._isIgnoredError(event, options)) {\n      if (isDebugBuild()) {\n        logger.warn(\"Event dropped due to being matched by `ignoreErrors` option.\\nEvent: \" + getEventDescription(event));\n      }\n      return true;\n    }\n    if (this._isDeniedUrl(event, options)) {\n      if (isDebugBuild()) {\n        logger.warn(\"Event dropped due to being matched by `denyUrls` option.\\nEvent: \" + getEventDescription(event) + \".\\nUrl: \" + this._getEventFilterUrl(event));\n      }\n      return true;\n    }\n    if (!this._isAllowedUrl(event, options)) {\n      if (isDebugBuild()) {\n        logger.warn(\"Event dropped due to not being matched by `allowUrls` option.\\nEvent: \" + getEventDescription(event) + \".\\nUrl: \" + this._getEventFilterUrl(event));\n      }\n      return true;\n    }\n    return false;\n  };\n  /** JSDoc */\n  InboundFilters.prototype._isSentryError = function (event, options) {\n    if (!options.ignoreInternal) {\n      return false;\n    }\n    try {\n      // @ts-ignore can't be a sentry error if undefined\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return event.exception.values[0].type === 'SentryError';\n    } catch (e) {\n      // ignore\n    }\n    return false;\n  };\n  /** JSDoc */\n  InboundFilters.prototype._isIgnoredError = function (event, options) {\n    if (!options.ignoreErrors || !options.ignoreErrors.length) {\n      return false;\n    }\n    return this._getPossibleEventMessages(event).some(function (message) {\n      // Not sure why TypeScript complains here...\n      return options.ignoreErrors.some(function (pattern) {\n        return isMatchingPattern(message, pattern);\n      });\n    });\n  };\n  /** JSDoc */\n  InboundFilters.prototype._isDeniedUrl = function (event, options) {\n    // TODO: Use Glob instead?\n    if (!options.denyUrls || !options.denyUrls.length) {\n      return false;\n    }\n    var url = this._getEventFilterUrl(event);\n    return !url ? false : options.denyUrls.some(function (pattern) {\n      return isMatchingPattern(url, pattern);\n    });\n  };\n  /** JSDoc */\n  InboundFilters.prototype._isAllowedUrl = function (event, options) {\n    // TODO: Use Glob instead?\n    if (!options.allowUrls || !options.allowUrls.length) {\n      return true;\n    }\n    var url = this._getEventFilterUrl(event);\n    return !url ? true : options.allowUrls.some(function (pattern) {\n      return isMatchingPattern(url, pattern);\n    });\n  };\n  /** JSDoc */\n  InboundFilters.prototype._mergeOptions = function (clientOptions) {\n    if (clientOptions === void 0) {\n      clientOptions = {};\n    }\n    return {\n      allowUrls: __spread(this._options.whitelistUrls || [], this._options.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),\n      denyUrls: __spread(this._options.blacklistUrls || [], this._options.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),\n      ignoreErrors: __spread(this._options.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),\n      ignoreInternal: typeof this._options.ignoreInternal !== 'undefined' ? this._options.ignoreInternal : true\n    };\n  };\n  /** JSDoc */\n  InboundFilters.prototype._getPossibleEventMessages = function (event) {\n    if (event.message) {\n      return [event.message];\n    }\n    if (event.exception) {\n      try {\n        var _a = event.exception.values && event.exception.values[0] || {},\n          _b = _a.type,\n          type = _b === void 0 ? '' : _b,\n          _c = _a.value,\n          value = _c === void 0 ? '' : _c;\n        return [\"\" + value, type + \": \" + value];\n      } catch (oO) {\n        if (isDebugBuild()) {\n          logger.error(\"Cannot extract message for event \" + getEventDescription(event));\n        }\n        return [];\n      }\n    }\n    return [];\n  };\n  /** JSDoc */\n  InboundFilters.prototype._getLastValidUrl = function (frames) {\n    if (frames === void 0) {\n      frames = [];\n    }\n    for (var i = frames.length - 1; i >= 0; i--) {\n      var frame = frames[i];\n      if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n        return frame.filename || null;\n      }\n    }\n    return null;\n  };\n  /** JSDoc */\n  InboundFilters.prototype._getEventFilterUrl = function (event) {\n    try {\n      if (event.stacktrace) {\n        return this._getLastValidUrl(event.stacktrace.frames);\n      }\n      var frames_1;\n      try {\n        // @ts-ignore we only care about frames if the whole thing here is defined\n        frames_1 = event.exception.values[0].stacktrace.frames;\n      } catch (e) {\n        // ignore\n      }\n      return frames_1 ? this._getLastValidUrl(frames_1) : null;\n    } catch (oO) {\n      if (isDebugBuild()) {\n        logger.error(\"Cannot extract url for event \" + getEventDescription(event));\n      }\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  InboundFilters.id = 'InboundFilters';\n  return InboundFilters;\n}();\nexport { InboundFilters };\n//# sourceMappingURL=inboundfilters.js.map","map":null,"metadata":{},"sourceType":"module"}
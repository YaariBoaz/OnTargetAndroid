{"ast":null,"code":"import { ShootingService } from './shooting.service';\nimport { DrillType } from '../../tab2/tab2.page';\nimport { StorageService } from './storage.service';\nimport { BehaviorSubject, Subject } from 'rxjs';\nimport { CountupTimerService } from 'ngx-timer';\nimport { ApiService } from './api.service';\nimport { UserService } from './user.service';\nimport * as moment from 'moment';\nimport { DrillStatus, TargetType } from '../drill/constants';\nimport { InitService } from './init.service';\nimport { BalisticCalculatorService } from './balistic-calculator.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./shooting.service\";\nimport * as i2 from \"./storage.service\";\nimport * as i3 from \"./init.service\";\nimport * as i4 from \"./balistic-calculator.service\";\nimport * as i5 from \"ngx-timer\";\nimport * as i6 from \"./api.service\";\nimport * as i7 from \"./user.service\";\nexport let GatewayService = /*#__PURE__*/(() => {\n  class GatewayService {\n    constructor(shootingService, storageService, initService, ballisticCalculatorService, counterUpTimerService, apiService, userService) {\n      this.shootingService = shootingService;\n      this.storageService = storageService;\n      this.initService = initService;\n      this.ballisticCalculatorService = ballisticCalculatorService;\n      this.counterUpTimerService = counterUpTimerService;\n      this.apiService = apiService;\n      this.userService = userService;\n      this.drillFinishedBefore = false;\n      this.drillFinished = false;\n      this.notifyTargetConnectedToGateway = new BehaviorSubject(null);\n      this.notifyHitNoHit = new Subject();\n      this.shots = [];\n      this.stats = [];\n      this.pageData = {\n        distanceFromCenter: 0,\n        splitTime: '',\n        rateOfFire: 0,\n        counter: 0,\n        points: 0,\n        isBarhan: false,\n        lastShotTime: null,\n        totalTime: '00:00:00'\n      };\n      this.notifyTargetBattery = new Subject();\n      this.notifyKeepAlive = new Subject();\n      this.notifyChellengeSaved = new Subject();\n      this.DEFAULT_PAGE_DATA = {\n        distanceFromCenter: 0,\n        splitTime: '',\n        rateOfFire: 0,\n        counter: 0,\n        isBarhan: false,\n        points: 0,\n        lastShotTime: null,\n        totalTime: '00:00:00'\n      };\n      this.hitArrived = new Subject();\n      this.summaryObject = {\n        points: 0,\n        distanceFromCenter: 0,\n        split: '0',\n        totalTime: '00:00:00',\n        counter: 0\n      };\n      this.notifyShotArrivedFromGateway = new BehaviorSubject(null);\n      this.drillFinishedNotify = new BehaviorSubject(null);\n      this.hits = [];\n      this.targets = [];\n    }\n    // Inits stats for drill when user starts a new drill\n    initStats() {\n      this.shots = [];\n      this.hits = [];\n      this.stats = [];\n      this.pageData = this.DEFAULT_PAGE_DATA;\n      this.startTimer();\n      this.hitArrived.next({\n        statsData: {\n          shot: null,\n          stats: [],\n          pageData: null,\n          isFinish: false,\n          summaryObject: null\n        }\n      });\n      this.drillFinished = false;\n    }\n    // Starts total time timer\n    startTimer() {\n      // tslint:disable-next-line:no-shadowed-variable max-line-length\n      const now = new Date();\n      this.firstTime = now;\n      this.lastTime = now;\n    }\n    // When drill is finished and the user decides to save the drill\n    updateHistory(isChallenge) {\n      this.drill = this.shootingService.selectedDrill;\n      let updatedData = this.storageService.getItem('homeData');\n      if (!updatedData) {\n        updatedData = {};\n      }\n      if (!updatedData.trainingHistory) {\n        updatedData.trainingHistory = [];\n      }\n      const splits = [];\n      this.stats.forEach(item => {\n        splits.push(item.pageData.splitTime);\n      });\n      let cId = null;\n      if (this.shootingService.isChallenge) {\n        cId = this.shootingService.challengeId;\n        cId = this.shootingService.selectedDrill.challngeId;\n      }\n      const hitsForServer = [];\n      this.hits.forEach(item => {\n        hitsForServer.push({\n          x: item.xPos,\n          y: item.yPos\n        });\n      });\n      const drill = {\n        challngeId: cId,\n        sessionId: this.userService.getUserId(),\n        sessionDateTime: new Date(),\n        userId: this.userService.getUserId(),\n        shotItems: this.getShotItems(),\n        drillDate: new Date(),\n        pointsGained: this.summaryObject.points,\n        timeLimit: 0,\n        bulletsHit: this.hits.length,\n        numberOfBullets: this.drill.numOfBullets,\n        drillTitle: DrillType[this.drill.drillType],\n        maxNumberOfPoints: 100000,\n        range: this.drill.range,\n        imageIdKey: '',\n        imageIdFullKey: 0,\n        hitsWithViewAdjustments: null,\n        avgDistFromCenter: this.summaryObject.distanceFromCenter,\n        description: '',\n        targetId: this.storageService.getItem('slectedTarget').name,\n        targetIP: '0',\n        useMoq: false,\n        drillType: parseInt(this.drill.drillType.toString()),\n        splitAvg: this.summaryObject.split,\n        numericSplitAvg: this.timeStringToSeconds(this.summaryObject.split),\n        timeElapsed: this.summaryObject.totalTime,\n        recomendation: '',\n        wepon: this.drill.weapon,\n        sight: this.drill.sight,\n        ammo: this.drill.ammo,\n        realibilty: '',\n        b2Drop: 0,\n        exposeTime: 0,\n        hideTime: 0,\n        rawHitsLocation: hitsForServer,\n        userName: this.userService.getUser().name,\n        status: DrillStatus.Done,\n        hitsToPass: 0,\n        grouping: this.groupingValue,\n        center: null,\n        epochTime: 0,\n        targetType: this.getTargetType(this.storageService.getItem('slectedTarget').name),\n        zone1Counter: 0,\n        zone2Counter: 0,\n        zone3Counter: 0,\n        location: null\n      };\n      this.apiService.syncDataGateway(drill).subscribe(() => {\n        this.notifyChellengeSaved.next(true);\n        this.apiService.getDashboardData(this.userService.getUserId()).subscribe(data1 => {\n          this.storageService.setItem('homeData', data1);\n          this.initService.newDashboardData.next(true);\n        });\n      });\n    }\n    // Updates current active drill stats.\n    updateStats(x, y, isFinish, distanceFromCenterPoints, zeroData) {\n      console.log('counter:', this.pageData.counter);\n      const currentdist = parseFloat(this.calculateBulletDistanceFromCenter(distanceFromCenterPoints.x, distanceFromCenterPoints.y).toFixed(2));\n      this.pageData.points = this.calcScore(currentdist * 2.54);\n      // tslint:disable-next-line:max-line-length\n      this.pageData.distanceFromCenter = currentdist;\n      if (!this.pageData.lastShotTime) {\n        this.pageData.lastShotTime = new Date();\n      }\n      if (zeroData) {\n        if (zeroData.isBarhan) {\n          this.pageData.isBarhan = true;\n        } else {\n          this.pageData.isBarhan = true;\n        }\n      }\n      // this.pageData.totalTime = (this.pageData.totalTime + ((new Date().getTime() - this.pageData.lastShotTime.getTime()) / 1000));\n      // this.pageData.lastShotTime = new Date();\n      // tslint:disable-next-line:no-shadowed-variable max-line-length\n      const now = new Date();\n      const split = moment.utc(moment(now, 'DD/MM/YYYY HH:mm:ss').diff(moment(this.lastTime, 'DD/MM/YYYY HH:mm:ss'))).format('mm:ss.SS');\n      const total = moment.utc(moment(now, 'DD/MM/YYYY HH:mm:ss').diff(moment(this.firstTime, 'DD/MM/YYYY HH:mm:ss'))).format('mm:ss.SS');\n      // tslint:disable-next-line:max-line-length\n      this.lastTime = new Date();\n      this.pageData.totalTime = total;\n      this.pageData.splitTime = split;\n      this.pageData.distanceFromCenter = parseFloat(this.calculateBulletDistanceFromCenter(distanceFromCenterPoints.x, distanceFromCenterPoints.y).toFixed(2));\n      this.stats.push({\n        pageData: Object.assign({}, this.pageData),\n        interval: this.pageData.totalTime\n      });\n      let points = 0;\n      let distanceFromCenter = 0;\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < this.stats.length; i++) {\n        points += this.stats[i].pageData.points;\n        distanceFromCenter += this.stats[i].pageData.distanceFromCenter;\n      }\n      const statsLength = this.stats.length;\n      this.summaryObject = {\n        points,\n        distanceFromCenter: this.getSummaryDistanceFromCenter(this.stats),\n        split: this.getSummarySplit(this.stats, statsLength),\n        totalTime: this.stats[statsLength - 1].interval,\n        counter: this.stats[statsLength - 1].pageData.counter\n      };\n      this.hitArrived.next({\n        statsData: {\n          shot: {\n            x,\n            y\n          },\n          stats: this.stats,\n          pageData: this.pageData,\n          isFinish,\n          summaryObject: this.summaryObject,\n          zeroData\n        }\n      });\n      // tslint:disable-next-line:max-line-length\n    }\n    // Notify components that drill has finished\n    finishDrill() {\n      this.drillFinishedBefore = true;\n      this.drillFinished = true;\n      this.drillFinishedNotify.next(true);\n    }\n    // Calculates the distance from center of the last shot.\n    calculateBulletDistanceFromCenter(xT, yT) {\n      var _a;\n      const targetId = (_a = this.storageService.getItem('slectedTarget')) === null || _a === void 0 ? void 0 : _a.name;\n      const targetType = this.getTargetType(targetId);\n      if (targetType === TargetType.Type_128) {\n        const centerX = 245;\n        const centerY = 245;\n        return parseFloat((Math.sqrt(Math.pow(xT - centerX, 2) + Math.pow(yT - centerY, 2)) / 10 / 2.54).toFixed(1));\n      } else if (targetType === TargetType.Type_64) {\n        const centerX = 16.303;\n        const centerY = 16.303;\n        const xRelative = xT / 4 * 1.8114;\n        const yRelative = yT / 4 * 1.8114;\n        return parseFloat((Math.sqrt(Math.pow(xRelative - centerX, 2) + Math.pow(yRelative - centerY, 2)) / 2.54).toFixed(1));\n      }\n    }\n    // Calculates the score of the last shot.\n    calcScore(dis) {\n      if (dis <= 2) {\n        return 11;\n      } else if (dis > 2 && dis <= 4) {\n        return 10;\n      } else if (dis > 4 && dis <= 7) {\n        return 9;\n      } else if (dis > 7 && dis <= 10) {\n        return 8;\n      } else if (dis > 10 && dis <= 14) {\n        return 7;\n      } else if (dis > 14 && dis <= 17.5) {\n        return 6;\n      } else if (dis > 17.5 && dis <= 21.5) {\n        return 5;\n      } else {\n        return 0;\n      }\n    }\n    // Receives the data from the ble service and parses to the correct function\n    processData(input) {\n      if (!this.drillFinished) {\n        if (!this.shootingService.numberOfBullersPerDrill || this.pageData.counter < this.shootingService.numberOfBullersPerDrill) {\n          const dataArray = input.replace('<,', '').replace(',>', '').split(',');\n          this.notifyKeepAlive.next(dataArray[0]);\n          const dataLength = dataArray.length;\n          const primB = dataArray[1];\n          switch (primB) {\n            case 'S':\n              this.handleShot_MSG_NEW(dataArray[2], dataArray[3]);\n              console.log('MESSAGE ARRIVED: ' + dataArray[2], dataArray[3]);\n              break;\n            case 'T':\n              this.hanldeBateryTime_MSG(dataArray);\n              break;\n            case 'B':\n              this.handleBatteryPrecentage_MSG(dataArray);\n              break;\n            case 'I':\n              this.handleImpact_MSG(dataArray);\n              break;\n            case 'SZ':\n              // tslint:disable-next-line:radix\n              this.notifyHitNoHit.next(parseInt(dataArray[3].split('\\n')[0]));\n              break;\n            default:\n              break;\n          }\n        }\n      }\n    }\n    // If gateway received a shot message\n    handleShot_MSG_NEW(x, y) {\n      var _a;\n      // !!!!!!!!          REMEMBER THE CALCULATION IS BY 210 NOT 220        !!!!!!!\n      // !!!!!!!!          REMEMBER THE CALCULATION IS BY 210 NOT 220        !!!!!!!\n      // !!!!!!!!          REMEMBER THE CALCULATION IS BY 210 NOT 220        !!!!!!!\n      const saveX = x;\n      const saveY = y;\n      const targetId = (_a = this.storageService.getItem('slectedTarget')) === null || _a === void 0 ? void 0 : _a.name;\n      const targetType = this.getTargetType(targetId);\n      let nominalStep;\n      let n;\n      let xPos;\n      let yPos;\n      if (targetType === TargetType.Type_64) {\n        xPos = Math.abs(3.75 * x - 30 - 210);\n        yPos = 3.75 * y - 30;\n      } else if (targetType === TargetType.Type_16) {\n        nominalStep = 7;\n        n = 5;\n        x = 0.25 * x - n;\n        y = 0.25 * y - n;\n        y -= 0.5;\n        x -= 0.5;\n        xPos = x;\n        yPos = y;\n      } else {\n        // 128\n        let disPointFromCenter128 = Math.sqrt(Math.pow(245 - x, 2) + Math.pow(245 - y, 2));\n        disPointFromCenter128 = disPointFromCenter128 / 10;\n        if (targetId.toLowerCase().indexOf('cs') > -1 || targetId.toLowerCase().indexOf('e128n4') > -1) {\n          if (targetId.toLowerCase().indexOf('e128n4') > -1) {\n            console.log('X IS: ', x);\n            console.log('Y IS: ', y);\n            // Y = a + bX\n            xPos = -0.4773 * x + 221.93;\n            yPos = 0.4773 * y - 11.932;\n          } else {\n            xPos = 0.58333 * x - 37.91667;\n            yPos = 0.58333 * y - 37.91667;\n          }\n        } else {\n          xPos = 0.5955 * x - 14.886;\n          yPos = 0.5955 * y - 14.886;\n        }\n      }\n      let zeroData = {};\n      zeroData = this.ballisticCalculatorService.updateShot(saveX, saveY, this.hits);\n      if (this.shootingService.getisZero()) {\n        if (zeroData.isBarhan) {\n          this.hits[this.hits.length - 1].isBarhan = true;\n        } else {\n          this.hits[this.hits.length - 1].isBarhan = false;\n        }\n      }\n      const disPointFromCenter = 1.905 * Math.sqrt(Math.pow(nominalStep / 2 - x, 2) + Math.pow(nominalStep / 2 - y, 2));\n      const orb = this.calcOrbital(disPointFromCenter);\n      this.pageData.counter++;\n      this.hits.push({\n        xPos,\n        yPos\n      });\n      if (this.pageData.counter > this.shootingService.numberOfBullersPerDrill) {\n        console.log('Shot After Drill Finished - Ignoring It');\n      } else if (this.pageData.counter === this.shootingService.numberOfBullersPerDrill) {\n        // tslint:disable-next-line:radix\n        this.updateStats(xPos, yPos, false, {\n          x: parseInt(saveX),\n          y: parseInt(saveY)\n        }, zeroData);\n        this.finishDrill();\n        // this.updateHistory();\n      } else {\n        // tslint:disable-next-line:radix\n        this.updateStats(xPos, yPos, false, {\n          x: parseInt(saveX),\n          y: parseInt(saveY)\n        }, zeroData);\n      }\n    }\n    // If gateway received a shot message\n    hanldeBateryTime_MSG(dataArray) {\n      const t = dataArray[2];\n      let bTime = 0;\n      if (t && t !== '') {\n        // tslint:disable-next-line:radix\n        bTime = parseInt(t);\n      }\n    }\n    // Update battery percentage\n    handleBatteryPrecentage_MSG(dataArray) {\n      const targetName = dataArray[0];\n      if (this.targets.indexOf(targetName) === -1) {\n        this.notifyTargetConnectedToGateway.next(targetName);\n        this.targets.push(targetName);\n      }\n      const b = dataArray[2];\n      let heartRate = 0;\n      if (b && b !== '') {\n        heartRate = parseFloat(b);\n      }\n      let bCharge = heartRate - 6;\n      bCharge = bCharge / 2.4 * 100;\n      if (bCharge > 100) {\n        bCharge = 100;\n      } else if (bCharge < 0) {\n        bCharge = 1;\n      }\n      this.batteryPercent = bCharge;\n      this.notifyTargetBattery.next(this.batteryPercent);\n      this.notifyTargetConnectedToGateway.next(true);\n    }\n    // handle shot from impact target.\n    handleImpact_MSG(dataArray) {\n      const i1 = dataArray[2];\n      let byte1 = 0;\n      {\n        // tslint:disable-next-line:radix\n        byte1 = parseInt(i1);\n      }\n      const i2 = dataArray[3];\n      let byte2 = 0;\n      if (i2 && i2 !== '') {\n        // tslint:disable-next-line:radix\n        byte2 = parseInt(i2);\n      }\n      const deviceImpacts = byte1 * 56 + byte2;\n      this.storageService.setItem('target-impacts', deviceImpacts);\n    }\n    // calculate split time.\n    getTimeDiffrence(str1, str2) {\n      console.log('In getTimeDifference: first STR: ' + str1 + ' second STR: ' + str2);\n      const arr1 = str1.split(':');\n      const arr2 = str2.split(':');\n      // tslint:disable-next-line:radix\n      const hoursArr1 = parseInt(arr1[0]);\n      // tslint:disable-next-line:radix\n      const hoursArr2 = parseInt(arr2[0]);\n      // tslint:disable-next-line:radix\n      const minArr1 = parseInt(arr1[1]);\n      // tslint:disable-next-line:radix\n      const minArr2 = parseInt(arr2[1]);\n      // tslint:disable-next-line:radix\n      const secArr1 = parseInt(arr1[2]);\n      // tslint:disable-next-line:radix\n      const secArr2 = parseInt(arr2[2]);\n      let newHour = Math.abs(hoursArr1 - hoursArr2);\n      let newMin = Math.abs(minArr1 - minArr2);\n      let newSec = Math.abs(secArr1 - secArr2);\n      if (newHour < 10) {\n        newHour = '0' + newHour;\n      }\n      if (newMin < 10) {\n        newMin = '0' + newMin;\n      }\n      if (newSec < 10) {\n        newSec = '0' + newSec;\n      }\n      console.log('New Split is : ' + newHour + ':' + newMin + ':' + newSec);\n      return newHour + ':' + newMin + ':' + newSec;\n    }\n    // Aggregate split time of current drill to get avg\n    getSummarySplit(stats, statsLength) {\n      if (stats) {\n        let totalSeconds = 0;\n        stats.forEach(stat => {\n          const arr = stat.pageData.splitTime.split(':');\n          const arr2 = arr[1].split('.');\n          // tslint:disable-next-line:radix\n          const minutes = parseInt(arr[0]) / 60;\n          // tslint:disable-next-line:radix\n          const seconds = parseInt(arr2[0]);\n          // tslint:disable-next-line:radix\n          const mili = parseInt(arr2[1]) / 1000;\n          totalSeconds += minutes + seconds + mili;\n        });\n        const date = new Date(0);\n        totalSeconds = totalSeconds / statsLength;\n        date.setSeconds(totalSeconds); // specify value for SECONDS here\n        let milisec = '0';\n        if (totalSeconds % 1 !== 0) {\n          milisec = totalSeconds.toString().split('.')[1];\n          if (milisec.length >= 2) {\n            milisec = milisec[1] + milisec[2];\n            // tslint:disable-next-line:radix\n            if (parseInt(milisec) > 60) {\n              totalSeconds += 1;\n              milisec = milisec[1];\n            }\n          }\n        }\n        const timeString = date.toISOString().substr(11, 8);\n        const finalArray = timeString.split(':');\n        return finalArray[1] + ':' + finalArray[2] + '.' + milisec;\n      }\n      return null;\n    }\n    // Aggregate distance from center of current drill to get avg\n    getSummaryDistanceFromCenter(stats) {\n      let avg = 0;\n      stats.forEach(item => {\n        avg += item.pageData.distanceFromCenter;\n      });\n      avg = avg / stats.length;\n      return Math.round((avg + Number.EPSILON) * 100) / 100;\n    }\n    // generates objects for server.\n    getShotItems() {\n      const shotItems = new Array();\n      this.stats.forEach(stat => {\n        shotItems.push({\n          disFromCenter: stat.pageData.distanceFromCenter.toString(),\n          hitHostage: false,\n          isHeader: false,\n          isOdd: false,\n          orbital: '0',\n          score: this.pageData.points.toString(),\n          shotNumber: '0',\n          time: stat.pageData.totalTime,\n          timeSplit: stat.pageData.splitTime\n        });\n      });\n      return shotItems;\n    }\n    // Parses an mm:ss string to seconds in number.\n    timeStringToSeconds(timeString) {\n      const timeArray = timeString.split(':');\n      let hour = 0;\n      const minutes = 0;\n      const seconds = 0;\n      if (timeArray[0] !== '00') {\n        let time = 0;\n        if (timeArray[0].charAt(0) !== '0') {\n          // tslint:disable-next-line:radix\n          time = parseInt(timeArray[0]);\n        } else {\n          // tslint:disable-next-line:radix\n          time = parseInt(timeArray[0].charAt(1));\n        }\n        hour = time * 3600;\n      }\n      if (timeArray[1] !== '00') {\n        const secAndMili = timeArray[1].split('.');\n        return parseFloat(secAndMili[0] + '.' + secAndMili[1]);\n      }\n      return hour + minutes + seconds;\n    }\n    calcOrbital(dis) {\n      if (dis <= 2) {\n        return 0;\n      } else if (dis > 2 && dis <= 4) {\n        return 1;\n      } else if (dis > 4 && dis <= 7) {\n        return 2;\n      } else if (dis > 7 && dis <= 10) {\n        return 3;\n      } else if (dis > 10 && dis <= 14) {\n        return 4;\n      } else {\n        return 5;\n      }\n    }\n    getTargetType(chosenTarget) {\n      if (chosenTarget.indexOf('003') > -1 || chosenTarget === '004') {\n        return TargetType.Type_64;\n      }\n      if (chosenTarget.indexOf('eMar') > -1) {\n        this.initService.isGateway = false;\n        return TargetType.HitNoHit;\n      }\n      // tslint:disable-next-line:radix\n      if (chosenTarget.indexOf('c') > -1) {\n        return TargetType.Type_128;\n      } else if (chosenTarget.indexOf('b') > -1) {\n        return TargetType.Type_64;\n      } else if (chosenTarget.indexOf('a') > -1) {\n        return TargetType.Type_16;\n      }\n      const num = parseInt(chosenTarget.split('e')[1].split('n')[0]);\n      switch (num) {\n        case 16:\n          return TargetType.Type_16;\n        case 64:\n          return TargetType.Type_64;\n        case 128:\n          return TargetType.Type_128;\n        default:\n          return TargetType.Type_64;\n      }\n    }\n  }\n  GatewayService.ɵfac = function GatewayService_Factory(t) {\n    return new (t || GatewayService)(i0.ɵɵinject(i1.ShootingService), i0.ɵɵinject(i2.StorageService), i0.ɵɵinject(i3.InitService), i0.ɵɵinject(i4.BalisticCalculatorService), i0.ɵɵinject(i5.CountupTimerService), i0.ɵɵinject(i6.ApiService), i0.ɵɵinject(i7.UserService));\n  };\n  GatewayService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GatewayService,\n    factory: GatewayService.ɵfac,\n    providedIn: 'root'\n  });\n  return GatewayService;\n})();","map":null,"metadata":{},"sourceType":"module"}
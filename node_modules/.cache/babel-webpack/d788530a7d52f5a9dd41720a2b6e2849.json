{"ast":null,"code":"// There're 2 types of Angular applications:\n// 1) zone-full (by default)\n// 2) zone-less\n// The developer can avoid importing the `zone.js` package and tells Angular that\n// he is responsible for running the change detection by himself. This is done by\n// \"nooping\" the zone through `CompilerOptions` when bootstrapping the root module.\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nvar isNgZoneEnabled = typeof Zone !== 'undefined' && !!Zone.current;\n/**\n * The function that does the same job as `NgZone.runOutsideAngular`.\n */\nexport function runOutsideAngular(callback) {\n  // The `Zone.root.run` basically will run the `callback` in the most parent zone.\n  // Any asynchronous API used inside the `callback` won't catch Angular's zone\n  // since `Zone.current` will reference `Zone.root`.\n  // The Angular's zone is forked from the `Zone.root`. In this case, `zone.js` won't\n  // trigger change detection, and `ApplicationRef.tick()` will not be run.\n  // Caretaker note: we're using `Zone.root` except `NgZone.runOutsideAngular` since this\n  // will require injecting the `NgZone` facade. That will create a breaking change for\n  // projects already using the `@sentry/angular`.\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return isNgZoneEnabled ? Zone.root.run(callback) : callback();\n}","map":{"version":3,"names":["isNgZoneEnabled","Zone","current","runOutsideAngular","callback","root","run"],"sources":["/Applications/OnTarget/OnTarget/node_modules/@sentry/angular/esm/zone.js"],"sourcesContent":["// There're 2 types of Angular applications:\n// 1) zone-full (by default)\n// 2) zone-less\n// The developer can avoid importing the `zone.js` package and tells Angular that\n// he is responsible for running the change detection by himself. This is done by\n// \"nooping\" the zone through `CompilerOptions` when bootstrapping the root module.\n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\nvar isNgZoneEnabled = typeof Zone !== 'undefined' && !!Zone.current;\n/**\n * The function that does the same job as `NgZone.runOutsideAngular`.\n */\nexport function runOutsideAngular(callback) {\n    // The `Zone.root.run` basically will run the `callback` in the most parent zone.\n    // Any asynchronous API used inside the `callback` won't catch Angular's zone\n    // since `Zone.current` will reference `Zone.root`.\n    // The Angular's zone is forked from the `Zone.root`. In this case, `zone.js` won't\n    // trigger change detection, and `ApplicationRef.tick()` will not be run.\n    // Caretaker note: we're using `Zone.root` except `NgZone.runOutsideAngular` since this\n    // will require injecting the `NgZone` facade. That will create a breaking change for\n    // projects already using the `@sentry/angular`.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return isNgZoneEnabled ? Zone.root.run(callback) : callback();\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,eAAe,GAAG,OAAOC,IAAI,KAAK,WAAW,IAAI,CAAC,CAACA,IAAI,CAACC,OAAO;AACnE;AACA;AACA;AACA,OAAO,SAASC,iBAAiB,CAACC,QAAQ,EAAE;EACxC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,OAAOJ,eAAe,GAAGC,IAAI,CAACI,IAAI,CAACC,GAAG,CAACF,QAAQ,CAAC,GAAGA,QAAQ,EAAE;AACjE"},"metadata":{},"sourceType":"module"}
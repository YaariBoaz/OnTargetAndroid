{"ast":null,"code":"/**\r\n * 3D slice module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Slice } from \"../Slice\";\nimport { Sprite } from \"../../Sprite\";\nimport * as $math from \"../../utils/Math\";\nimport * as $path from \"../../rendering/Path\";\nimport * as $type from \"../../utils/Type\";\nimport { Color, color } from \"../../utils/Color\";\nimport { RadialGradient } from \"../../rendering/fills/RadialGradient\";\nimport { LinearGradient } from \"../../rendering/fills/LinearGradient\";\nimport { LightenFilter } from \"../../rendering/filters/LightenFilter\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to draw a 3D slice of a Pie chart.\r\n *\r\n * @see {@link ISlice3DEvents} for a list of available events\r\n * @see {@link ISlice3DAdapters} for a list of available Adapters\r\n */\nvar Slice3D = /** @class */function (_super) {\n  __extends(Slice3D, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Slice3D() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this.className = \"Slice3D\";\n    _this.layout = \"none\";\n    // Create edge container\n    var edge = _this.createChild(Sprite);\n    _this.edge = edge;\n    edge.shouldClone = false;\n    edge.isMeasured = false;\n    edge.toBack();\n    // Set defaults\n    _this.angle = 30;\n    _this.depth = 20;\n    // Create side A element\n    var sideA = _this.createChild(Sprite);\n    _this.sideA = sideA;\n    sideA.shouldClone = false;\n    sideA.isMeasured = false;\n    //sideA.setElement(this.paper.add(\"path\"));\n    //sideA.strokeOpacity = 0;\n    // Crate side B element\n    var sideB = _this.createChild(Sprite);\n    _this.sideB = sideB;\n    sideB.shouldClone = false;\n    sideB.isMeasured = false;\n    //sideB.setElement(this.paper.add(\"path\"));\n    //sideB.strokeOpacity = 0;\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Sets actual `fill` property on the SVG element, including applicable color\r\n   * modifiers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param value  Fill\r\n   */\n  Slice3D.prototype.setFill = function (value) {\n    _super.prototype.setFill.call(this, value);\n    var colorStr;\n    if (value instanceof Color) {\n      colorStr = value.hex;\n    } else if (value instanceof LinearGradient || value instanceof RadialGradient) {\n      colorStr = value.stops.getIndex(0).color.hex;\n    } else {\n      var filter = new LightenFilter();\n      filter.lightness = -0.25;\n      this.edge.filters.push(filter);\n      this.sideA.filters.push(filter.clone());\n      this.sideB.filters.push(filter.clone());\n    }\n    if (colorStr) {\n      var edgeFill = color(colorStr).lighten(-0.25);\n      this.edge.fill = edgeFill;\n      this.sideA.fill = edgeFill;\n      this.sideB.fill = edgeFill;\n      this.edge.stroke = edgeFill;\n      this.sideA.stroke = edgeFill;\n      this.sideB.stroke = edgeFill;\n    }\n  };\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Slice3D.prototype.draw = function () {\n    this.cornerRadius = 0;\n    this.innerCornerRadius = 0;\n    _super.prototype.draw.call(this);\n    if (this.arc !== 0 && this.radius > 0 && this.depth > 0) {\n      this.sideB.show(0);\n      this.sideA.show(0);\n      this.edge.show(0);\n      var startAngle = this.startAngle;\n      var arc = this.arc;\n      var innerRadius = this.pixelInnerRadius || 0;\n      var radiusY = this.radiusY || 0;\n      //let cornerRadius = this.cornerRadius || 0;\n      //let innerCornerRadius = this.innerCornerRadius;\n      var radius = this.radius;\n      // this is code duplicate with $path.arc. @todo to think how to avoid it\n      var endAngle = startAngle + arc;\n      //let crSin = $math.sin($math.min(arc, 45) / 2);\n      //innerCornerRadius = innerCornerRadius || cornerRadius;\n      var innerRadiusY = radiusY / radius * innerRadius;\n      //let cornerRadiusY = (radiusY / radius) * cornerRadius;\n      //let innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\n      //cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\n      //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n      //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\n      //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n      //cornerRadius = $math.fitToRange(cornerRadius, 0, radius * crSin);\n      //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, radiusY * crSin);\n      //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, innerRadius * crSin);\n      //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin);\n      //let crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\n      //let crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\n      //if (innerRadius < innerCornerRadius) {\n      //\tinnerRadius = innerCornerRadius;\n      //}\n      //if (innerRadiusY < innerCornerRadiusY) {\n      //\tinnerRadiusY = innerCornerRadiusY;\n      //}\n      //let crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\n      //let crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\n      //if (!$type.isNumber(crInnerAngle)) {\n      //\tcrInnerAngle = 0;\n      //}\n      //if (!$type.isNumber(crInnerAngleY)) {\n      //\tcrInnerAngleY = 0;\n      //}\n      //let middleAngle = startAngle + arc / 2;\n      //let mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.round($math.sin(middleAngle) * innerRadiusY, 4) };\n      var a0 = {\n        x: $math.cos(startAngle) * innerRadius,\n        y: $math.sin(startAngle) * innerRadiusY\n      };\n      var b0 = {\n        x: $math.cos(startAngle) * radius,\n        y: $math.sin(startAngle) * radiusY\n      };\n      var c0 = {\n        x: $math.cos(endAngle) * radius,\n        y: $math.sin(endAngle) * radiusY\n      };\n      var d0 = {\n        x: $math.cos(endAngle) * innerRadius,\n        y: $math.sin(endAngle) * innerRadiusY\n      };\n      // end of duplicate\n      var h = this.depth;\n      var ah = {\n        x: a0.x,\n        y: a0.y - h\n      };\n      var bh = {\n        x: b0.x,\n        y: b0.y - h\n      };\n      var ch = {\n        x: c0.x,\n        y: c0.y - h\n      };\n      var dh = {\n        x: d0.x,\n        y: d0.y - h\n      };\n      var edgePath = \"\";\n      var count = Math.ceil(arc / 5);\n      var step = arc / count;\n      var mangle = startAngle;\n      var prevPoint = bh;\n      for (var i = 0; i < count; i++) {\n        mangle += step;\n        if (mangle > 0 && mangle < 180) {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * radius,\n            y: $math.sin(mangle) * radiusY - h\n          };\n          edgePath += $path.lineTo({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: pp.x,\n            y: pp.y + h\n          }, radius, radiusY, true);\n          edgePath += $path.lineTo(pp);\n          edgePath += $path.arcToPoint(prevPoint, radius, radiusY);\n          edgePath += \"z\";\n          prevPoint = pp;\n        } else {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * radius,\n            y: $math.sin(mangle) * radiusY - h\n          };\n          edgePath += $path.arcToPoint(pp, radius, radiusY, true);\n          edgePath += $path.lineTo({\n            x: pp.x,\n            y: pp.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          }, radius, radiusY);\n          edgePath += $path.lineTo(prevPoint);\n          edgePath += \"z\";\n          prevPoint = pp;\n        }\n      }\n      prevPoint = ah;\n      mangle = startAngle;\n      for (var i = 0; i < count; i++) {\n        mangle += step;\n        if (mangle > 0 && mangle < 180) {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * innerRadius,\n            y: $math.sin(mangle) * innerRadiusY - h\n          };\n          edgePath += $path.lineTo({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: pp.x,\n            y: pp.y + h\n          }, innerRadius, innerRadiusY, true);\n          edgePath += $path.lineTo(pp);\n          edgePath += $path.arcToPoint(prevPoint, innerRadius, innerRadiusY);\n          edgePath += \"z\";\n          prevPoint = pp;\n        } else {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * innerRadius,\n            y: $math.sin(mangle) * innerRadiusY - h\n          };\n          edgePath += $path.arcToPoint(pp, innerRadius, innerRadiusY, true);\n          edgePath += $path.lineTo({\n            x: pp.x,\n            y: pp.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          }, innerRadius, innerRadiusY);\n          edgePath += $path.lineTo(prevPoint);\n          edgePath += \"z\";\n          prevPoint = pp;\n        }\n      }\n      this.edge.path = edgePath;\n      /*\r\n                  a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                  b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n                  c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n                  d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                  // end of duplicate\r\n      \r\n                  ah = { x: a0.x, y: a0.y - h };\r\n                  bh = { x: b0.x, y: b0.y - h };\r\n                  ch = { x: c0.x, y: c0.y - h };\r\n                  dh = { x: d0.x, y: d0.y - h };\r\n      */\n      this.sideA.path = $path.moveTo(a0) + $path.lineTo(b0) + $path.lineTo(bh) + $path.lineTo(ah) + $path.closePath();\n      this.sideB.path = $path.moveTo(c0) + $path.lineTo(d0) + $path.lineTo(dh) + $path.lineTo(ch) + $path.closePath();\n      if (this.startAngle < 90) {\n        this.sideA.toBack();\n      } else {\n        this.sideA.toFront();\n      }\n      if (this.startAngle + this.arc > 90) {\n        this.sideB.toBack();\n      } else {\n        this.sideB.toFront();\n      }\n      this.slice.dy = -h;\n    } else {\n      this.sideA.hide(0);\n      this.sideB.hide(0);\n      this.edge.hide(0);\n    }\n  };\n  Object.defineProperty(Slice3D.prototype, \"depth\", {\n    /**\r\n     * @return Depth (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"depth\");\n    },\n    /**\r\n     * Depth (height) of the 3D slice in pixels.\r\n     *\r\n     * @default 20\r\n     * @param depth  Depth (px)\r\n     */\n    set: function (depth) {\n      this.setPropertyValue(\"depth\", depth, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slice3D.prototype, \"angle\", {\n    /**\r\n     * @return Angle\r\n     */\n    get: function () {\n      var angle = this.getPropertyValue(\"angle\");\n      if (!$type.isNumber(angle)) {\n        angle = 0;\n      }\n      return angle;\n    },\n    /**\r\n     * Angle of the point of view to the 3D element. (0-360)\r\n     *\r\n     * @default 30\r\n     * @param value  Angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"angle\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slice3D.prototype, \"radiusY\", {\n    /**\r\n     * @return Vertical radius (0-1)\r\n     */\n    get: function () {\n      var radiusY = this.getPropertyValue(\"radiusY\");\n      if (!$type.isNumber(radiusY)) {\n        radiusY = this.radius - this.radius * this.angle / 90;\n      }\n      return radiusY;\n    },\n    /**\r\n     * Vertical radius for creating skewed slices.\r\n     *\r\n     * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half\r\n     * the `radius`.\r\n     *\r\n     * @param value Vertical radius (0-1)\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"radiusY\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n  Slice3D.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n    this.edge.copyFrom(source.edge);\n    this.sideA.copyFrom(source.sideA);\n    this.sideB.copyFrom(source.sideB);\n  };\n  return Slice3D;\n}(Slice);\nexport { Slice3D };\n//# sourceMappingURL=Slice3D.js.map","map":null,"metadata":{},"sourceType":"module"}
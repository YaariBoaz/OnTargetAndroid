{"ast":null,"code":"import { ShootingService } from './shooting.service';\nimport { Subject } from 'rxjs';\nimport { ApiService } from './api.service';\nimport { InitService } from './init.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./shooting.service\";\nimport * as i2 from \"./api.service\";\nimport * as i3 from \"./init.service\";\nexport let BalisticCalculatorService = /*#__PURE__*/(() => {\n  class BalisticCalculatorService {\n    constructor(shootingService, apiService, initService) {\n      this.shootingService = shootingService;\n      this.apiService = apiService;\n      this.initService = initService;\n      this.mNumShots = 0;\n      this.mZeroHits = new Array();\n      this.uiZeroShots = new Array();\n      this.divHeight = 300;\n      this.divWidth = 300;\n      this.moa = 0;\n      this.notifyZeroShot = new Subject();\n      this.sessionHits = [];\n      this.divHeight = this.initService.screenH;\n      this.divWidth = this.initService.screenW;\n      this.getZeroTableInit();\n      this.divWidth = this.initService.screenW;\n      this.divHeight = this.initService.screenH;\n      if (this.divWidth > this.divHeight) {\n        this.divWidth = this.divHeight - 100;\n      } else {\n        this.divHeight = this.divWidth - 100;\n      }\n    }\n    resetStats() {\n      this.mZeroHits = new Array();\n      this.uiZeroShots = new Array();\n      this.mNumShots = 0;\n    }\n    getCentroid(hits) {\n      let totalX = 0;\n      let totalY = 0;\n      hits.forEach(hit => {\n        totalX += hit.x;\n        totalY += hit.y;\n      });\n      const centerX = totalX / hits.length;\n      const centerY = totalY / hits.length;\n      return new Hit(centerX, centerY);\n    }\n    calcDistance(hitA, hitB) {\n      return Math.sqrt(Math.pow(hitA.x - hitB.x, 2) + Math.pow(hitA.y - hitB.y, 2));\n    }\n    getZeroTableInit() {\n      this.getZeroTable({\n        ballisticCoefficient: 0.121,\n        initialVelocity: 1190,\n        sightHeight: 2.5,\n        zeroRange: 250,\n        boreAngle: 0,\n        windangle: 90,\n        yIntercept: 0,\n        altitude: 0,\n        barometer: 29.59,\n        temperature: 59,\n        relativeHumidity: 0.5,\n        windSpeed: 0,\n        isMetric: true\n      }).subscribe(data => {\n        this.shootingService.zeroTable = data;\n      });\n    }\n    standardDeviation(hits) {\n      const v = this.constiance(hits);\n      return Math.sqrt(v);\n    }\n    average(hits) {\n      let total = 0;\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < hits.length; i++) {\n        total += hits[i].DisFromCenter;\n      }\n      const avg = total / hits.length;\n      return avg;\n    }\n    constiance(hits) {\n      let n = 0;\n      let mean = 0;\n      let M2 = 0;\n      hits.forEach(hit => {\n        const x = hit.disFromCenter;\n        n = n + 1;\n        const delta = x - mean;\n        mean = mean + delta / n;\n        M2 += delta * (x - mean);\n      });\n      return M2 / (n - 1);\n    }\n    calculateGrouping(hits) {\n      let maxDix = 0;\n      for (let i = 0; i < hits.length; i++) {\n        for (let j = 0; j < hits.length; j++) {\n          if (i === j) {\n            continue;\n          }\n          const dis = this.calcDistance(hits[i], hits[j]);\n          if (dis > maxDix) {\n            maxDix = dis;\n          }\n        }\n      }\n      return maxDix;\n    }\n    calcDistanceFromCenter(x, y, targetType) {\n      let nominalStep;\n      let n;\n      if (targetType === TargetType.Type_64) {\n        nominalStep = 15;\n        n = 1;\n        x = 0.25 * x - n;\n        y = 0.25 * y - n;\n        y -= 0.5;\n        x -= 0.5;\n      } else if (targetType === TargetType.Type_16) {\n        nominalStep = 7;\n        n = 5;\n        x = 0.25 * x - n;\n        y = 0.25 * y - n;\n        y -= 0.5;\n        x -= 0.5;\n      } else\n        // case of 128 target\n        {\n          if (targetType === TargetType.Type_128 && this.shootingService.chosenTarget === 'e128n2' || this.shootingService.chosenTarget === 'e128n4') {\n            nominalStep = 8;\n            x = x / nominalStep;\n            y = y / nominalStep;\n          }\n          // else\n          {\n            return Math.sqrt(Math.pow(245 - x, 2) + Math.pow(245 - y, 2)) / 10;\n          }\n        }\n      return 1.905 * Math.sqrt(Math.pow(nominalStep / 2 - x, 2) + Math.pow(nominalStep / 2 - y, 2));\n    }\n    calcPostions(x, y, targetType) {\n      let nominalStep;\n      let n;\n      if (targetType === TargetType.Type_64) {\n        nominalStep = 15;\n        n = 1;\n        x = 0.25 * x - n;\n        y = 0.25 * y - n;\n        y -= 0.5;\n      } else if (targetType === TargetType.Type_16) {\n        nominalStep = 7;\n        n = 5;\n        x = 0.25 * x - n;\n        y = 0.25 * y - n;\n        y -= 0.5;\n        x -= 0.5;\n      } else\n        // case of 128 target\n        {\n          if (targetType === TargetType.Type_128 && this.shootingService.chosenTarget === 'e128n2' || this.shootingService.chosenTarget === 'e128n4') {\n            nominalStep = 8;\n            x = x / nominalStep;\n            y = y / nominalStep;\n          }\n          // else\n          {\n            const disPointFromCenter128 = Math.sqrt(Math.pow(245 - x, 2) + Math.pow(245 - y, 2)) / 10;\n            x = this.divWidth / 490 * x - 7;\n            y = this.divHeight / 490 * y;\n            const data128 = new ZeroHitData(x, y);\n            data128.DisFromCenter = disPointFromCenter128;\n            return data128;\n          }\n        }\n      const w = this.divWidth;\n      const h = this.divHeight;\n      const xStep = w / nominalStep;\n      const yStep = h / nominalStep;\n      const xPos = xStep * x;\n      const yPos = yStep * y;\n      const disPointFromCenter = 1.905 * Math.sqrt(Math.pow(nominalStep / 2 - x, 2) + Math.pow(nominalStep / 2 - y, 2));\n      const data = new ZeroHitData(xPos, yPos);\n      data.DisFromCenter = disPointFromCenter;\n      return data;\n    }\n    calcNapar(doDraw, targetType) {\n      // tslint:disable-next-line:prefer-const\n      const range = this.shootingService.selectedDrill.range;\n      let path2CM = 0.6; // this is a table that you need to build in startup  m_zeroTable[m_DrillInfo.Range].PathCM;\n      path2CM = this.shootingService.zeroTable[range].pathCM;\n      path2CM = 3;\n      let val = 36 - path2CM * 2;\n      let dataNapar;\n      const targertName = JSON.parse(localStorage.getItem('slectedTarget')).name;\n      if (targetType === TargetType.Type_128) {\n        if (targertName === 'e128n2' || targertName === 'e128n4')\n          // (target is 128 and the id is e128n2 or e128n4)\n          {\n            dataNapar = this.calcPostions(245 / 7.55, val, targetType);\n          } else {\n          const middleYPointInCM = 24.5;\n          val = (middleYPointInCM - path2CM) * 10;\n          dataNapar = this.calcPostions(245, val, targetType);\n        }\n      } else {\n        dataNapar = this.calcPostions(32, val, targetType);\n      }\n      return {\n        napar: dataNapar,\n        yNapar: val,\n        doDraw\n      };\n    }\n    calcNapam(hits) {\n      const centerHit = this.getCentroid(hits);\n      const center = new ZeroHitData(centerHit.x, centerHit.y);\n      let maxDisBetweenPoints = 0;\n      // tslint:disable-next-line:prefer-for-of\n      for (let i = 0; i < hits.length; i++) {\n        hits[i].DisFromCenter = this.calcDistance(hits[i], center);\n      }\n      const std = this.standardDeviation(hits);\n      const avg = this.average(hits);\n      if (hits.length > 2) {\n        hits.forEach((hit, i) => {\n          {\n            const dr = Math.abs(hit.disFromCenter - std);\n            if (dr > avg) {\n              console.log('Found Anmoly:[{' + hit.x + '},{ ' + hit.y + '}]');\n              if (hit.DisFromCenter && hit.isBarhan) {\n                hit.isBarhan = true;\n                this.sessionHits[i].isBarhan = true;\n                this.sessionHits[i].DisFromCenter = hit.DisFromCenter;\n                this.sessionHits[i].isBarhan = false;\n              }\n            } else {\n              if (hit.DisFromCenter && hit.isBarhan) {\n                hit.isBarhan = false;\n                this.sessionHits[i].DisFromCenter = hit.DisFromCenter;\n                this.sessionHits[i].isBarhan = false;\n              }\n            }\n          }\n          ;\n        });\n        const hitWithoutBarhans = hits.filter(item => {\n          return item.isBarhan === false;\n        });\n        maxDisBetweenPoints = this.calculateGrouping(hitWithoutBarhans);\n        const newNapam = this.getCentroid(hitWithoutBarhans);\n        return {\n          napam: newNapam,\n          grouping: maxDisBetweenPoints\n        };\n      } else {\n        return {\n          napam: centerHit,\n          grouping: maxDisBetweenPoints\n        };\n      }\n    }\n    getZeroStatus(napar2napamDis, maxDisBetweenPoints) {\n      if (maxDisBetweenPoints > 20) {\n        return 'Scattered';\n      } else {\n        if (napar2napamDis < 3) {\n          return 'Zeroed';\n        } else {\n          return 'Shoot Again';\n        }\n      }\n    }\n    calcClicks(disFromNAPARInInches, xy, range, clickMOA) {\n      const normalized1MOA = range / 100.0 * 1.26;\n      const moaDistance = disFromNAPARInInches / 2.54 / normalized1MOA;\n      const clicks = Math.round(moaDistance / clickMOA);\n      return clicks;\n    }\n    setClickViews(napam, napar, devider, range, moa, targetType) {\n      const napar2napamDis = this.calcDistance(new ZeroHitData(napam.napam.x, napam.napam.y), new ZeroHitData(napar.x, napar.y));\n      const leftOrRightClicks = this.calcClicks(Math.abs(napam.napam.x - napar.x) / devider, 'X', range, moa);\n      const upOrDownClicks = this.calcClicks(Math.abs(napam.napam.y - napar.y) / devider, 'Y', range, moa);\n      let right = 0;\n      let left = 0;\n      let up = 0;\n      let down = 0;\n      if (targetType === TargetType.Type_128) {\n        if (true)\n          // (target is !![not]!! 128 and the id is e128n2 or e128n4)\n          {\n            if (napam.napam.x > napar.x) {\n              right = leftOrRightClicks;\n            } else {\n              left = leftOrRightClicks;\n            }\n          } else {\n          if (napam.napam.x < napar.x) {\n            right = leftOrRightClicks;\n          } else {\n            left = leftOrRightClicks;\n          }\n        }\n      } else {\n        if (napam.napam.x > napar.x) {\n          right = leftOrRightClicks;\n        } else {\n          left = leftOrRightClicks;\n        }\n        if (napam.napam.y > napar.y) {\n          up = upOrDownClicks;\n        } else {\n          down = upOrDownClicks;\n        }\n      }\n      return {\n        rightClick: right,\n        leftClick: left,\n        upclick: up,\n        downClick: down,\n        isBarhan: false,\n        napar2Napam: napar2napamDis,\n        status: undefined,\n        naparResults: undefined,\n        naparView: undefined,\n        napamToView: undefined\n      };\n    }\n    calcGrouping(hits) {\n      console.log('HITS IN calcGrouping:', hits);\n      let disGroup = 0;\n      const group = new ZeroHitData(0, 0);\n      const nonBarahnHits = [];\n      hits.forEach(item => {\n        nonBarahnHits.push(item);\n        // }\n      });\n\n      console.log('nonBarahnHits IN calcGrouping:', hits);\n      const ordered = nonBarahnHits.sort((n1, n2) => n2.DisFromCenter - n1.DisFromCenter);\n      console.log('ordered IN calcGrouping:', hits);\n      if (ordered.length >= 2) {\n        const a = new Hit(ordered[0].xPos, ordered[0].yPos);\n        const b = new Hit(ordered[1].xPos, ordered[1].yPos);\n        console.log('A: ', a);\n        console.log('B: ', b);\n        disGroup = Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)) / 10;\n        console.log('disGroup: ', disGroup);\n        let xN = 0;\n        let yN = 0;\n        nonBarahnHits.forEach(item => {\n          xN += item.xPos;\n          yN += item.yPos;\n        });\n        group.xPos = xN / nonBarahnHits.length;\n        group.yPos = yN / nonBarahnHits.length;\n      }\n      const returnObject = {\n        disGroup,\n        hit: new Hit(group.x, group.y)\n      };\n      console.log('returnObject IN calcGrouping:', returnObject);\n      return returnObject;\n    }\n    updateZeroTableAndTargetUI(x, y, isBarhan, disFromCenter) {\n      const data = this.calcPostions(x, y, this.targetType);\n      // m_DrillInfo.RawHitsLocation.Add(new Hit(x, y));\n      // m_DrillInfo.HitsWithViewAdjustments.Add(new Hit(data.XPosition, data.YPositon));\n      const uiHitData = new ZeroHitData(data.x, data.y);\n      uiHitData.isBarhan = isBarhan;\n      uiHitData.DisFromCenter = disFromCenter;\n      uiHitData.index = this.mNumShots;\n      this.uiZeroShots.push(uiHitData);\n      this.uiZeroShots.forEach(hit => {\n        const hitMatch = this.mZeroHits.find(element => element.index === hit.index);\n        hit.isBarhan = hitMatch.isBarhan;\n      });\n      const napamToView = this.calcGrouping(this.sessionHits);\n      console.log('NAPAMTOVIEW FROM UPDATEZEROTABLE', napamToView);\n      return napamToView;\n    }\n    updateShot(x, y, hits) {\n      // new hit arrvies\n      // determent which target is this (16,64,128)\n      this.sessionHits = hits;\n      debugger;\n      try {\n        this.mNumShots++;\n        const timesStrings = {}; // get splittime and total time for the hits\n        let adjusments = 0.4688;\n        let midPoint = 36;\n        let devider = 1;\n        const targertName = JSON.parse(localStorage.getItem('slectedTarget')).name;\n        this.setTargetType(targertName);\n        if (this.targetType === TargetType.Type_128) {\n          adjusments = 1;\n          midPoint = 245;\n          devider = 10;\n          if (this.targetType === TargetType.Type_128 && (targertName === 'e128n2' || targertName === 'e128n4')) {\n            x = x / 7.59;\n            y = y / 7.52;\n            adjusments = 0.4688;\n            midPoint = 36;\n            devider = 1;\n          }\n        }\n        const naparResults = this.calcNapar(false, this.targetType);\n        const naparData = new Hit(adjusments * midPoint, adjusments * naparResults.yNapar);\n        const naparView = new Hit(naparResults.napar.x, naparResults.napar.y);\n        const naparToCalcClikcs = new Hit(naparData.x, naparData.y);\n        // Add New Hit\n        const newHit = new Hit(adjusments * x, adjusments * y);\n        const newZeroHit = new ZeroHitData(newHit.x, newHit.y);\n        newZeroHit.index = this.mNumShots;\n        this.mZeroHits.push(newZeroHit);\n        // Get NAPAM\n        let napamToCalcClicks = this.calcNapam(this.mZeroHits);\n        let isBarhan = false;\n        if (this.sessionHits[this.sessionHits.length - 1].isBarhan) {\n          isBarhan = true;\n        }\n        if (!napamToCalcClicks) {\n          napamToCalcClicks = {\n            napam: {\n              x: 0,\n              y: 0\n            },\n            grouping: null\n          };\n        }\n        const latestHitData = this.sessionHits[this.sessionHits.length - 1];\n        const napamDistanceFromCenter = this.calcDistanceFromCenter(x, y, this.targetType);\n        const napamToView = this.updateZeroTableAndTargetUI(latestHitData.x, latestHitData.y, latestHitData.isBarhan, napamDistanceFromCenter);\n        console.log('NAPAMTOVIEW: ', napamToView);\n        const clicks = this.setClickViews(napamToCalcClicks, naparToCalcClikcs, devider, this.shootingService.selectedDrill.range, this.shootingService.getMOABySight(), this.targetType);\n        let status;\n        if (napamToCalcClicks.grouping > 10) {\n          status = 'Scattered';\n        } else if (napamToCalcClicks.grouping < 10 && napamToCalcClicks.grouping > 5) {\n          status = 'Good Grouping';\n        } else {\n          status = 'Excellent';\n        }\n        clicks.status = status;\n        clicks.isBarhan = isBarhan;\n        clicks.naparResults = naparResults;\n        clicks.napamToView = napamToView.hit;\n        clicks.naparView = naparView;\n        clicks.napar2Napam = napamToView.disGroup;\n        console.log('clicks.napar2Napam: ', clicks.napar2Napam);\n        this.grouping = clicks.napar2Napam / 2.54;\n        return clicks;\n        if (this.mNumShots === this.shootingService.numberOfBullersPerDrill) {\n          const zeroStatus = this.getZeroStatus(clicks.napar2Napam, napamToCalcClicks.grouping);\n          clicks.status = zeroStatus;\n          clicks.naparResults = naparResults;\n          clicks.napamToView = napamToView;\n          clicks.naparView = naparView;\n          return clicks;\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    lastShot() {\n      // do your last shot logic (restart, save to db upload drill etc...)\n    }\n    setTargetType(name) {\n      if (name === '003' || name.indexOf('64')) {\n        this.targetType = TargetType.Type_64;\n      } else if (name.indexOf('128') > -1) {\n        this.targetType = TargetType.Type_128;\n      } else {\n        this.targetType = TargetType.Type_16;\n      }\n    }\n    onControlLoaded() {\n      this.calcNapar(true, TargetType.Type_128);\n    }\n    getZeroTable(data) {\n      return this.apiService.getZeroTable(data);\n    }\n    getCaliberMapping() {\n      return this.apiService.getCaliberMapping();\n    }\n    getCalibersTable() {\n      return this.apiService.getCalibersTable();\n    }\n    getWepons() {\n      return this.apiService.getWepons();\n    }\n    getSightsZeroing() {\n      return this.apiService.getSightsZeroing();\n    }\n    getBullets() {\n      return this.apiService.getBullets();\n    }\n    getBallisticData(weaponName, sightName) {\n      return this.apiService.getBallisticData(weaponName, sightName);\n    }\n  }\n  BalisticCalculatorService.ɵfac = function BalisticCalculatorService_Factory(t) {\n    return new (t || BalisticCalculatorService)(i0.ɵɵinject(i1.ShootingService), i0.ɵɵinject(i2.ApiService), i0.ɵɵinject(i3.InitService));\n  };\n  BalisticCalculatorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: BalisticCalculatorService,\n    factory: BalisticCalculatorService.ɵfac,\n    providedIn: 'root'\n  });\n  return BalisticCalculatorService;\n})();\nexport class ZeroHitData {\n  constructor(xPos, yPos) {\n    this.x = xPos;\n    this.y = yPos;\n    this.isBarhan = false;\n  }\n}\nexport class Hit {\n  constructor(xPos, yPos) {\n    this.x = xPos;\n    this.y = yPos;\n  }\n}\nvar TargetType = /*#__PURE__*/(() => {\n  (function (TargetType) {\n    TargetType[TargetType[\"Type_128\"] = 0] = \"Type_128\";\n    TargetType[TargetType[\"Type_64\"] = 1] = \"Type_64\";\n    TargetType[TargetType[\"Type_16\"] = 2] = \"Type_16\";\n    TargetType[TargetType[\"Type_PUP\"] = 3] = \"Type_PUP\";\n  })(TargetType || (TargetType = {}));\n  return TargetType;\n})();","map":null,"metadata":{},"sourceType":"module"}
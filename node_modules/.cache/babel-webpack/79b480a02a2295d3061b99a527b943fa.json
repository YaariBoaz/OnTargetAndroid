{"ast":null,"code":"/**\r\n * Handles date and time formatting\r\n */\nimport { __extends } from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $time from \"../utils/Time\";\n/**\r\n * Handles date and time formatting.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/} Tutorial on date/time formatting\r\n * @todo Better type casting of passed in date?\r\n * @todo Quarter support?\r\n * @todo When parsing named months make the search case-insensitive\r\n * @todo Escape a.m./p.m. properly when used in RegEx\r\n */\nvar DateFormatter = /** @class */function (_super) {\n  __extends(DateFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Date format.\r\n     */\n    _this._dateFormat = \"yyyy-MM-dd\";\n    /**\r\n     * Input date format.\r\n     */\n    _this._inputDateFormat = \"yyyy-MM-dd\";\n    /**\r\n     * Assume UTC time zone.\r\n     */\n    _this._utc = false;\n    /**\r\n     * If `timezone` is set, this will hold minute fraction of the timezone.\r\n     *\r\n     * @readonly\r\n     * @ignore\r\n     */\n    _this.timezoneMinutes = 0;\n    /**\r\n     * First day of week.\r\n     *\r\n     * 0 - Sunday\r\n     * 1 - Monday\r\n     *\r\n     * Etc.\r\n     */\n    _this._firstDayOfWeek = 1;\n    /**\r\n     * A list of month names.\r\n     */\n    _this.months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    /**\r\n     * A list of short month names.\r\n     */\n    _this.monthsShort = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May(short)\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    /**\r\n     * A list of weekday names.\r\n     */\n    _this.weekdays = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    /**\r\n     * A list of short weekday names.\r\n     */\n    _this.weekdaysShort = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    /**\r\n     * Output format to produce. If the format calls for applying color to the\r\n     * formatted value, this setting will determine what markup to use: SVG or\r\n     * HTML.\r\n     *\r\n     * Available options: svg, html.\r\n     *\r\n     * @default \"svg\"\r\n     */\n    _this._outputFormat = \"svg\";\n    /**\r\n     * Should the first letter of the formatted date be capitalized?\r\n     *\r\n     * @default true\r\n     */\n    _this.capitalize = true;\n    _this.className = \"DateFormatter\";\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(DateFormatter.prototype, \"language\", {\n    /**\r\n     * @return Language\r\n     */\n    get: function () {\n      return this._language;\n    },\n    /**\r\n     * A reference to [[Language]] object.\r\n     *\r\n     * @param  value  Language\r\n     */\n    set: function (value) {\n      this._language = value;\n      this.dateFormat = this._language.translate(\"_date\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Formats the date value according to specified format.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/} Tutorial on date/time formatting\r\n   * @param source  Date value\r\n   * @param format  Format\r\n   * @return Formatted date string\r\n   */\n  DateFormatter.prototype.format = function (source, format, applyTimezone) {\n    // No language?\n    if (!this.language) {\n      if (this.sprite) {\n        this.language = this.sprite.language;\n      } else {\n        this.language = new Language();\n      }\n    }\n    // No format passed in or it's empty\n    if (typeof format === \"undefined\" || format === \"\") {\n      format = this._dateFormat;\n    }\n    // Init return value\n    var formatted;\n    // Do casting if required\n    // This will take care of timestamps as well as Date objects\n    var date;\n    if ($type.isString(source)) {\n      // If it's a string, let's try parsing it using our own functionality\n      date = this.parse(source);\n    } else {\n      date = $utils.anyToDate(source);\n    }\n    // Is it a built-in format or Intl.DateTimeFormat\n    if ($type.isObject(format)) {\n      try {\n        if (this.intlLocales) {\n          return new Intl.DateTimeFormat(this.intlLocales, format).format(date);\n        } else {\n          return new Intl.DateTimeFormat(undefined, format).format(date);\n        }\n      } catch (e) {\n        return \"Invalid\";\n      }\n    } else {\n      // Clean format\n      format = $utils.cleanFormat(format);\n      // get format info (it will also deal with parser caching)\n      var info = this.parseFormat(format);\n      // Should we apply custom time zone?\n      if ($type.hasValue(this.timezoneOffset)) {\n        date.setMinutes(date.getMinutes() + date.getTimezoneOffset() - this.timezoneOffset);\n      } else if ($type.hasValue(this.timezone) && applyTimezone !== false) {\n        date = $time.setTimezone(date, this.timezone);\n      }\n      // Check if it's a valid date\n      if (!$type.isNumber(date.getTime())) {\n        return this.language.translate(\"Invalid date\");\n      }\n      // Apply format\n      formatted = this.applyFormat(date, info, this.language);\n      // Capitalize\n      if (this.capitalize) {\n        formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());\n      }\n    }\n    // We're done\n    return formatted;\n  };\n  /**\r\n   * Parses format into structured infromation.\r\n   *\r\n   * @param format Format template\r\n   */\n  DateFormatter.prototype.parseFormat = function (format) {\n    // Check cache\n    var cached = this.getCache(format);\n    if ($type.hasValue(cached)) {\n      return cached;\n    }\n    // Init format parse info holder\n    var info = {\n      \"template\": \"\",\n      \"parts\": []\n    };\n    // Let TextFormatter split into chunks\n    var chunks = getTextFormatter().chunk(format, true);\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n      if (chunk.type === \"value\") {\n        // Just \"Date\"?\n        if (chunk.text.match(/^date$/i) && $type.isString(this._dateFormat)) {\n          chunk.text = this._dateFormat;\n        }\n        // Find all possible parts\n        var matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);\n        // Found?\n        if (matches) {\n          // Populate template\n          for (var x = 0; x < matches.length; x++) {\n            info.parts.push(matches[x]);\n            chunk.text = chunk.text.replace(matches[x], $strings.PLACEHOLDER);\n          }\n        }\n      }\n      // Apply to template\n      info.template += chunk.text;\n    }\n    // Apply style formatting\n    //info.template = getTextFormatter().format(info.template, this.outputFormat);\n    // Save cache\n    this.setCache(format, info);\n    return info;\n  };\n  /**\r\n   * Applies format to Date.\r\n   *\r\n   * @param date      Date object\r\n   * @param info      Parsed format information\r\n   * @param language  Language\r\n   * @return Formatted date string\r\n   */\n  DateFormatter.prototype.applyFormat = function (date, info, language) {\n    // Init return value\n    var res = info.template;\n    // Get values\n    var fullYear,\n      month,\n      weekday,\n      day,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      offset = date.getTimezoneOffset(),\n      timestamp = date.getTime();\n    if (this.utc) {\n      fullYear = date.getUTCFullYear();\n      month = date.getUTCMonth();\n      weekday = date.getUTCDay();\n      day = date.getUTCDate();\n      hours = date.getUTCHours();\n      minutes = date.getUTCMinutes();\n      seconds = date.getUTCSeconds();\n      milliseconds = date.getUTCMilliseconds();\n    } else {\n      fullYear = date.getFullYear();\n      month = date.getMonth();\n      weekday = date.getDay();\n      day = date.getDate();\n      hours = date.getHours();\n      minutes = date.getMinutes();\n      seconds = date.getSeconds();\n      milliseconds = date.getMilliseconds();\n    }\n    // Go through each part and format/replace it in template\n    for (var i = 0, len = info.parts.length; i < len; i++) {\n      var value = \"\";\n      switch (info.parts[i]) {\n        case \"G\":\n          value = language.translate(fullYear < 0 ? \"_era_bc\" : \"_era_ad\");\n          break;\n        case \"yyyy\":\n          value = Math.abs(fullYear).toString();\n          if (fullYear < 0) {\n            value += language.translate(\"_era_bc\");\n          }\n          break;\n        case \"yyy\":\n        case \"yy\":\n        case \"y\":\n          value = Math.abs(fullYear).toString().substr(-info.parts[i].length);\n          if (fullYear < 0) {\n            value += language.translate(\"_era_bc\");\n          }\n          break;\n        case \"YYYY\":\n        case \"YYY\":\n        case \"YY\":\n        case \"Y\":\n          var week = $utils.getWeek(date);\n          var year = fullYear;\n          if (week == 1 && weekday > 4) {\n            year--;\n          }\n          if (info.parts[i] == \"YYYY\") {\n            value = Math.abs(year).toString();\n          } else {\n            value = Math.abs(year).toString().substr(-info.parts[i].length);\n          }\n          if (year < 0) {\n            value += language.translate(\"_era_bc\");\n          }\n          break;\n        case \"u\":\n          // @todo\n          break;\n        case \"q\":\n          value = \"\" + Math.ceil((date.getMonth() + 1) / 3);\n          break;\n        case \"MMMMM\":\n          value = language.translate(this.months[month]).substr(0, 1);\n          break;\n        case \"MMMM\":\n          value = language.translate(this.months[month]);\n          break;\n        case \"MMM\":\n          value = language.translate(this.monthsShort[month]);\n          break;\n        case \"MM\":\n          value = $utils.padString(month + 1, 2, \"0\");\n          break;\n        case \"M\":\n          value = (month + 1).toString();\n          break;\n        case \"ww\":\n          value = $utils.padString($utils.getWeek(date, this.utc), 2, \"0\");\n          break;\n        case \"w\":\n          value = $utils.getWeek(date, this.utc).toString();\n          break;\n        case \"W\":\n          value = $utils.getMonthWeek(date, this.utc).toString();\n          break;\n        case \"dd\":\n          value = $utils.padString(day, 2, \"0\");\n          break;\n        case \"d\":\n          value = day.toString();\n          break;\n        case \"DD\":\n        case \"DDD\":\n          value = $utils.padString($utils.getYearDay(date, this.utc).toString(), info.parts[i].length, \"0\");\n          break;\n        case \"D\":\n          value = $utils.getYearDay(date, this.utc).toString();\n          break;\n        case \"F\":\n          // @todo\n          break;\n        case \"g\":\n          // @todo\n          break;\n        case \"t\":\n          value = language.translateFunc(\"_dateOrd\").call(this, day);\n          break;\n        case \"E\":\n          value = (weekday || 7).toString();\n          break;\n        case \"EE\":\n          value = $utils.padString((weekday || 7).toString(), 2, \"0\");\n          break;\n        case \"EEE\":\n        case \"eee\":\n          value = language.translate(this.weekdaysShort[weekday]);\n          break;\n        case \"EEEE\":\n        case \"eeee\":\n          value = language.translate(this.weekdays[weekday]);\n          break;\n        case \"EEEEE\":\n        case \"eeeee\":\n          value = language.translate(this.weekdays[weekday]).substr(0, 1);\n          break;\n        case \"e\":\n        case \"ee\":\n          value = (weekday - this.firstDayOfWeek + 1).toString();\n          if (info.parts[i] == \"ee\") {\n            value = $utils.padString(value, 2, \"0\");\n          }\n          break;\n        case \"a\":\n          if (hours >= 12) {\n            value = language.translate(\"PM\");\n          } else {\n            value = language.translate(\"AM\");\n          }\n          break;\n        case \"aa\":\n          if (hours >= 12) {\n            value = language.translate(\"P.M.\");\n          } else {\n            value = language.translate(\"A.M.\");\n          }\n          break;\n        case \"aaa\":\n          if (hours >= 12) {\n            value = language.translate(\"P\");\n          } else {\n            value = language.translate(\"A\");\n          }\n          break;\n        case \"h\":\n          value = $utils.get12Hours(hours).toString();\n          break;\n        case \"hh\":\n          value = $utils.padString($utils.get12Hours(hours), 2, \"0\");\n          break;\n        case \"H\":\n          value = hours.toString();\n          break;\n        case \"HH\":\n          value = $utils.padString(hours, 2, \"0\");\n          break;\n        case \"K\":\n          value = $utils.get12Hours(hours, 0).toString();\n          break;\n        case \"KK\":\n          value = $utils.padString($utils.get12Hours(hours, 0), 2, \"0\");\n          break;\n        case \"k\":\n          value = (hours + 1).toString();\n          break;\n        case \"kk\":\n          value = $utils.padString(hours + 1, 2, \"0\");\n          break;\n        case \"m\":\n          value = minutes.toString();\n          break;\n        case \"mm\":\n          value = $utils.padString(minutes, 2, \"0\");\n          break;\n        case \"s\":\n          value = seconds.toString();\n          break;\n        case \"ss\":\n          value = $utils.padString(seconds, 2, \"0\");\n          break;\n        case \"S\":\n        case \"SS\":\n        case \"SSS\":\n          value = Math.round(milliseconds / 1000 * Math.pow(10, info.parts[i].length)).toString();\n          break;\n        case \"x\":\n          value = timestamp.toString();\n          break;\n        case \"n\":\n        case \"nn\":\n        case \"nnn\":\n          value = $utils.padString(milliseconds, info.parts[i].length, \"0\");\n          break;\n        case \"z\":\n          value = $utils.getTimeZone(date, false, false, this.utc);\n          break;\n        case \"zz\":\n          value = $utils.getTimeZone(date, true, false, this.utc);\n          break;\n        case \"zzz\":\n          value = $utils.getTimeZone(date, false, true, this.utc);\n          break;\n        case \"zzzz\":\n          value = $utils.getTimeZone(date, true, true, this.utc);\n          break;\n        case \"Z\":\n        case \"ZZ\":\n          var tz = Math.abs(offset) / 60;\n          var tzh = Math.floor(tz);\n          var tzm = tz * 60 - tzh * 60;\n          if (this.utc) {\n            tzh = 0;\n            tzm = 0;\n          }\n          if (info.parts[i] == \"Z\") {\n            value = \"GMT\";\n            value += offset > 0 ? \"-\" : \"+\";\n            value += $utils.padString(tzh, 2) + \":\" + $utils.padString(tzm, 2);\n          } else {\n            value = offset > 0 ? \"-\" : \"+\";\n            value += $utils.padString(tzh, 2) + $utils.padString(tzm, 2);\n          }\n          break;\n        case \"i\":\n          value = date.toISOString();\n          break;\n        case \"I\":\n          value = date.toUTCString();\n          break;\n      }\n      res = res.replace($strings.PLACEHOLDER, value);\n    }\n    return res;\n  };\n  /**\r\n   * Parses any input value into Date object.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date/time parsing\r\n   * @param source  Source value\r\n   * @param format  Source format\r\n   * @return Date object\r\n   */\n  DateFormatter.prototype.parse = function (source, format) {\n    // Format set?\n    if (!$type.hasValue(format)) {\n      format = this.inputDateFormat;\n    }\n    // Is it already a Date\n    if (source instanceof Date) {\n      return source;\n    }\n    // Is it a numeric timestamp\n    if (typeof source === \"number\") {\n      return new Date(source);\n    }\n    // No? Let's check if it's string, and try converting to it if nec\n    if (typeof source !== \"string\") {\n      source = source.toString();\n    }\n    // no language?\n    if (!this.language) {\n      if (this.sprite) {\n        this.language = this.sprite.language;\n      } else {\n        this.language = new Language();\n      }\n    }\n    // Init return value\n    var res;\n    // Init RegEx for parsing\n    var reg = \"\";\n    // Clean format\n    format = $utils.cleanFormat(format);\n    // Clip format to length of the source string\n    format = format.substr(0, source.length);\n    // Parse format\n    var info = this.parseFormat(format);\n    // Init parsed items holder\n    var parsedIndexes = {\n      \"year\": -1,\n      \"year3\": -1,\n      \"year2\": -1,\n      \"year1\": -1,\n      \"month\": -1,\n      \"monthShort\": -1,\n      \"monthLong\": -1,\n      \"weekdayShort\": -1,\n      \"weekdayLong\": -1,\n      \"day\": -1,\n      \"yearDay\": -1,\n      \"week\": -1,\n      \"hourBase0\": -1,\n      \"hour12Base0\": -1,\n      \"hourBase1\": -1,\n      \"hour12Base1\": -1,\n      \"minute\": -1,\n      \"second\": -1,\n      \"millisecond\": -1,\n      \"millisecondDigits\": -1,\n      \"am\": -1,\n      \"zone\": -1,\n      \"timestamp\": -1,\n      \"iso\": -1\n    };\n    // Init values\n    var resValues = {\n      \"year\": 1970,\n      \"month\": 0,\n      \"day\": 1,\n      \"hour\": 0,\n      \"minute\": 0,\n      \"second\": 0,\n      \"millisecond\": 0,\n      \"timestamp\": null,\n      \"offset\": 0,\n      \"utc\": this.utc\n    };\n    // Index adjuster\n    var indexAdjust = 0,\n      index = 0;\n    // Iterate through all of the parts\n    for (var i = 0; i < info.parts.length; i++) {\n      // Set current match index\n      index = i + indexAdjust + 1;\n      switch (info.parts[i]) {\n        case \"yyyy\":\n        case \"YYYY\":\n          reg += \"([0-9]{4})\";\n          parsedIndexes.year = index;\n          break;\n        case \"yyy\":\n        case \"YYY\":\n          reg += \"([0-9]{3})\";\n          parsedIndexes.year3 = index;\n          break;\n        case \"yy\":\n        case \"YY\":\n          reg += \"([0-9]{2})\";\n          parsedIndexes.year2 = index;\n          break;\n        case \"y\":\n        case \"Y\":\n          reg += \"([0-9]{1})\";\n          parsedIndexes.year1 = index;\n          break;\n        case \"MMMM\":\n          reg += \"(\" + this.getStringList(this.months).join(\"|\") + \")\";\n          parsedIndexes.monthLong = index;\n          break;\n        case \"MMM\":\n          reg += \"(\" + this.getStringList(this.monthsShort).join(\"|\") + \")\";\n          parsedIndexes.monthShort = index;\n          break;\n        case \"MM\":\n        case \"M\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.month = index;\n          break;\n        case \"ww\":\n        case \"w\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.week = index;\n          break;\n        case \"dd\":\n        case \"d\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.day = index;\n          break;\n        case \"DDD\":\n        case \"DD\":\n        case \"D\":\n          reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n          parsedIndexes.yearDay = index;\n          break;\n        case \"dddd\":\n          reg += \"(\" + this.getStringList(this.weekdays).join(\"|\") + \")\";\n          parsedIndexes.weekdayLong = index;\n          break;\n        case \"ddd\":\n          reg += \"(\" + this.getStringList(this.weekdaysShort).join(\"|\") + \")\";\n          parsedIndexes.weekdayShort = index;\n          break;\n        case \"aaa\":\n        case \"aa\":\n        case \"a\":\n          // TODO: fix (escape regex)\n          reg += \"(\" + this.getStringList([\"AM\", \"PM\", \"A\\.M\\.\", \"P\\.M\\.\", \"A\", \"P\"]).join(\"|\") + \")\";\n          parsedIndexes.am = index;\n          break;\n        case \"hh\":\n        case \"h\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hour12Base1 = index;\n          break;\n        case \"HH\":\n        case \"H\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hourBase0 = index;\n          break;\n        case \"KK\":\n        case \"K\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hour12Base0 = index;\n          break;\n        case \"kk\":\n        case \"k\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.hourBase1 = index;\n          break;\n        case \"mm\":\n        case \"m\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.minute = index;\n          break;\n        case \"ss\":\n        case \"s\":\n          reg += \"([0-9]{2}|[0-9]{1})\";\n          parsedIndexes.second = index;\n          break;\n        case \"SSS\":\n        case \"SS\":\n        case \"S\":\n          reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n          parsedIndexes.millisecond = index;\n          parsedIndexes.millisecondDigits = info.parts[i].length;\n          break;\n        case \"nnn\":\n        case \"nn\":\n        case \"n\":\n          reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n          parsedIndexes.millisecond = index;\n          break;\n        case \"x\":\n          reg += \"([0-9]{1,})\";\n          parsedIndexes.timestamp = index;\n          break;\n        case \"Z\":\n          reg += \"GMT([-+]+[0-9]{2}:[0-9]{2})\";\n          parsedIndexes.zone = index;\n          break;\n        case \"ZZ\":\n          reg += \"([\\\\-+]+[0-9]{2}[0-9]{2})\";\n          parsedIndexes.zone = index;\n          break;\n        case \"i\":\n          reg += \"([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)\";\n          parsedIndexes.iso = index;\n          indexAdjust += 7;\n          break;\n        case \"G\":\n        case \"YYYY\":\n        case \"YYY\":\n        case \"YY\":\n        case \"Y\":\n        case \"MMMMM\":\n        case \"W\":\n        case \"EEEEE\":\n        case \"EEEE\":\n        case \"EEE\":\n        case \"EE\":\n        case \"E\":\n        case \"eeeee\":\n        case \"eeee\":\n        case \"eee\":\n        case \"ee\":\n        case \"e\":\n        case \"zzzz\":\n        case \"zzz\":\n        case \"zz\":\n        case \"z\":\n        case \"t\":\n          // Ignore\n          indexAdjust--;\n          break;\n      }\n      reg += \"[^0-9]*\";\n    }\n    // Try matching\n    var regex = new RegExp(reg);\n    var matches = source.match(regex);\n    if (matches) {\n      // Populate the date object\n      // Full year\n      if (parsedIndexes.year > -1) {\n        resValues.year = parseInt(matches[parsedIndexes.year]);\n      }\n      // 3-digit year\n      if (parsedIndexes.year3 > -1) {\n        var val = parseInt(matches[parsedIndexes.year3]);\n        val += 1000;\n        resValues.year = val;\n      }\n      // 2-digit year\n      if (parsedIndexes.year2 > -1) {\n        var val = parseInt(matches[parsedIndexes.year2]);\n        if (val > 50) {\n          val += 1000;\n        } else {\n          val += 2000;\n        }\n        resValues.year = val;\n      }\n      // 1-digit year\n      if (parsedIndexes.year1 > -1) {\n        var val = parseInt(matches[parsedIndexes.year1]);\n        val = Math.floor(new Date().getFullYear() / 10) * 10 + val;\n        resValues.year = val;\n      }\n      // Full month\n      if (parsedIndexes.monthLong > -1) {\n        resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);\n      }\n      // Short month\n      if (parsedIndexes.monthShort > -1) {\n        resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);\n      }\n      // Numeric month\n      if (parsedIndexes.month > -1) {\n        resValues.month = parseInt(matches[parsedIndexes.month]) - 1;\n      }\n      // Weekday\n      // @todo\n      // Week\n      if (parsedIndexes.week > -1 && parsedIndexes.day === -1) {\n        // We parse weeks ONLY if day is not explicitly set\n        // TODO: this needs work\n        // (but maybe later - I can hardly imagine anyone passing their dates in weeks)\n        resValues.month = 0;\n        resValues.day = $utils.getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this.utc);\n      }\n      // Day\n      if (parsedIndexes.day > -1) {\n        resValues.day = parseInt(matches[parsedIndexes.day]);\n      }\n      // Year day\n      if (parsedIndexes.yearDay > -1) {\n        resValues.month = 0;\n        resValues.day = parseInt(matches[parsedIndexes.yearDay]);\n      }\n      // 24 Hour (0-23)\n      if (parsedIndexes.hourBase0 > -1) {\n        resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);\n      }\n      // 24 Hour (1-24)\n      if (parsedIndexes.hourBase1 > -1) {\n        resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;\n      }\n      // 12 Hour (0-11)\n      if (parsedIndexes.hour12Base0 > -1) {\n        var val = parseInt(matches[parsedIndexes.hour12Base0]);\n        if (val == 11) {\n          val = 0;\n        }\n        if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n          val += 12;\n        }\n        resValues.hour = val;\n      }\n      // 12 Hour (1-12)\n      if (parsedIndexes.hour12Base1 > -1) {\n        var val = parseInt(matches[parsedIndexes.hour12Base1]);\n        if (val == 12) {\n          val = 0;\n        }\n        if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n          val += 12;\n        }\n        resValues.hour = val;\n      }\n      // Minute\n      if (parsedIndexes.minute > -1) {\n        resValues.minute = parseInt(matches[parsedIndexes.minute]);\n      }\n      // Second\n      if (parsedIndexes.second > -1) {\n        resValues.second = parseInt(matches[parsedIndexes.second]);\n      }\n      // Millisecond\n      if (parsedIndexes.millisecond > -1) {\n        var val = parseInt(matches[parsedIndexes.millisecond]);\n        if (parsedIndexes.millisecondDigits == 2) {\n          val *= 10;\n        } else if (parsedIndexes.millisecondDigits == 1) {\n          val *= 100;\n        }\n        resValues.millisecond = val;\n      }\n      // Timestamp\n      if (parsedIndexes.timestamp > -1) {\n        resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);\n        var ts = new Date(resValues.timestamp);\n        resValues.year = ts.getUTCFullYear();\n        resValues.month = ts.getUTCMonth();\n        resValues.day = ts.getUTCDate();\n        resValues.hour = ts.getUTCHours();\n        resValues.minute = ts.getUTCMinutes();\n        resValues.second = ts.getUTCSeconds();\n        resValues.millisecond = ts.getUTCMilliseconds();\n      }\n      // Adjust time zone\n      if (parsedIndexes.zone > -1) {\n        resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);\n      }\n      // ISO\n      if (parsedIndexes.iso > -1) {\n        resValues.year = $type.toNumber(matches[parsedIndexes.iso + 0]);\n        resValues.month = $type.toNumber(matches[parsedIndexes.iso + 1]) - 1;\n        resValues.day = $type.toNumber(matches[parsedIndexes.iso + 2]);\n        resValues.hour = $type.toNumber(matches[parsedIndexes.iso + 3]);\n        resValues.minute = $type.toNumber(matches[parsedIndexes.iso + 4]);\n        resValues.second = $type.toNumber(matches[parsedIndexes.iso + 5]);\n        resValues.millisecond = $type.toNumber(matches[parsedIndexes.iso + 6]);\n        if (matches[parsedIndexes.iso + 7] == \"Z\" || matches[parsedIndexes.iso + 7] == \"z\") {\n          resValues.utc = true;\n        } else if (matches[parsedIndexes.iso + 7] != \"\") {\n          resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);\n        }\n      }\n      // Create Date object\n      if (resValues.utc) {\n        res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));\n      } else {\n        res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);\n      }\n    } else {\n      // Didn't match anything\n      // Let's try dropping it into Date constructor and hope for the best\n      res = new Date(source);\n    }\n    return res;\n  };\n  DateFormatter.prototype.resolveTimezoneOffset = function (date, zone) {\n    var value = zone.match(/([+\\-]?)([0-9]{2}):?([0-9]{2})/);\n    if (value) {\n      var match = $type.getValue(zone.match(/([+\\-]?)([0-9]{2}):?([0-9]{2})/));\n      var dir = match[1];\n      var hour = match[2];\n      var minute = match[3];\n      var offset = parseInt(hour) * 60 + parseInt(minute);\n      // Adjust offset\n      // Making it negative does not seem to make sense, but it's right\n      // because of how JavaScript calculates GMT offsets\n      if (dir == \"+\") {\n        offset *= -1;\n      }\n      // Check the difference in offset\n      var originalOffset = (date || new Date()).getTimezoneOffset();\n      var diff = offset - originalOffset;\n      return diff;\n    }\n    return 0;\n  };\n  /**\r\n   * Resolves month name (i.e. \"December\") into a month number (11).\r\n   *\r\n   * @param value  Month name\r\n   * @return Month number\r\n   */\n  DateFormatter.prototype.resolveMonth = function (value) {\n    // Let's try English first\n    var month = this.months.indexOf(value);\n    if (month > -1) {\n      return month;\n    }\n    // Try the translation\n    if (this.language && !this.language.isDefault()) {\n      month = this.language.translateAll(this.months).indexOf(value);\n      if (month > -1) {\n        return month;\n      }\n    }\n    return 0;\n  };\n  /**\r\n   * Resolves short month name (i.e. \"Dec\") into a month number.\r\n   *\r\n   * @param value  Short month name\r\n   * @return Month number\r\n   */\n  DateFormatter.prototype.resolveShortMonth = function (value) {\n    // Let's try English first\n    var month = this.monthsShort.indexOf(value);\n    if (month > -1) {\n      return month;\n    }\n    // Maybe long month (workaround for May)\n    month = this.months.indexOf(value);\n    if (month > -1) {\n      return month;\n    }\n    // Try the translation\n    if (this.language && !this.language.isDefault()) {\n      month = this.language.translateAll(this.monthsShort).indexOf(value);\n      if (month > -1) {\n        return month;\n      }\n    }\n    return 0;\n  };\n  /**\r\n   * Checks if passed in string represents AM/PM notation in many of its\r\n   * versions.\r\n   *\r\n   * @param value  Source string\r\n   * @return Is it AM/PM?\r\n   */\n  DateFormatter.prototype.isAm = function (value) {\n    var list = this.getStringList([\"AM\", \"A.M.\", \"A\"]);\n    return list.indexOf(value.toUpperCase()) > -1;\n  };\n  /**\r\n   * Invalidates related [[Sprite]] causing it to redraw.\r\n   */\n  DateFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n  /**\r\n   * Translates list of strings.\r\n   *\r\n   * @param list  Source strings\r\n   * @return Translated strings\r\n   */\n  DateFormatter.prototype.getStringList = function (list) {\n    var res = [];\n    for (var i = 0; i < list.length; i++) {\n      // translate?\n      if (this.language) {\n        res.push($utils.escapeForRgex(this.language.translate(list[i])));\n      } else {\n        res.push($utils.escapeForRgex(list[i]));\n      }\n    }\n    return res;\n  };\n  Object.defineProperty(DateFormatter.prototype, \"dateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._dateFormat;\n    },\n    /**\r\n     * Date format to use.\r\n     *\r\n     * If format is not supplied in-line in the string, this setting will be\r\n     * used.\r\n     *\r\n     * @default \"yyyy-MM-dd\"\r\n     * @param value Date format\r\n     */\n    set: function (value) {\n      this._dateFormat = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"inputDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._inputDateFormat;\n    },\n    /**\r\n     * Date format to use when parsing dates.\r\n     *\r\n     * @default \"yyyy-MM-dd\"\r\n     * @param value Date format\r\n     */\n    set: function (value) {\n      this._inputDateFormat = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"intlLocales\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._intlLocales;\n    },\n    /**\r\n     * Locales if you are using date formats in `Intl.DateTimeFormatOptions` syntax.\r\n     *\r\n     * @param value Locales\r\n     */\n    set: function (value) {\n      this._intlLocales = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"utc\", {\n    /**\r\n     * @return Use UTC?\r\n     */\n    get: function () {\n      return this._utc;\n    },\n    /**\r\n     * Should formatter use UTC functions?\r\n     *\r\n     * If UTC is used, all date/time values will be independent on client's\r\n     * time zone.\r\n     *\r\n     * @param value Use UTC?\r\n     */\n    set: function (value) {\n      this._utc = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"timezoneOffset\", {\n    /**\r\n     * @return Offset (minutes)\r\n     */\n    get: function () {\n      return this._timezoneOffset;\n    },\n    /**\r\n     * If set, will apply specific offset in minutes before formatting the date\r\n     * text.\r\n     *\r\n     * The value is a number of minutes from target time zone to UTC.\r\n     *\r\n     * E.g. `300` will recalculate Dates in \"GMT-5\" time zone.\r\n     *\r\n     * @param  value  Offset (minutes)\r\n     */\n    set: function (value) {\n      if (this._timezoneOffset != value) {\n        this._timezoneOffset = value;\n        this.invalidateSprite();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"timezone\", {\n    /**\r\n     * @return Timezone\r\n     */\n    get: function () {\n      return this._timezone;\n    },\n    /**\r\n     * If set, will format date/time in specific time zone.\r\n     *\r\n     * The value should be named time zone, e.g.:\r\n     * `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`.\r\n     *\r\n     * @since 4.10.1\r\n     * @param  value  Timezone\r\n     */\n    set: function (value) {\n      if (this._timezone != value) {\n        this._timezone = value;\n        this.timezoneMinutes = $time.getTimezoneMinutes(value);\n        this.invalidateSprite();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"firstDayOfWeek\", {\n    /**\r\n     * @return First day of week\r\n     */\n    get: function () {\n      return this._firstDayOfWeek;\n    },\n    /**\r\n     * First day of the week:\r\n     *\r\n     * * 0 - Sunday\r\n     * * 1 - Monday\r\n     * * 2 - Tuesday\r\n     *\r\n     * Etc.\r\n     *\r\n     * @param value First day of week\r\n     */\n    set: function (value) {\n      this._firstDayOfWeek = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateFormatter.prototype, \"outputFormat\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Format\r\n     */\n    get: function () {\n      return this._outputFormat;\n    },\n    /**\r\n     * Output format for the formatted date.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Format\r\n     */\n    set: function (value) {\n      this._outputFormat = value.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateFormatter;\n}(BaseObject);\nexport { DateFormatter };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"DateFormatter\"] = DateFormatter;\n//# sourceMappingURL=DateFormatter.js.map","map":null,"metadata":{},"sourceType":"module"}
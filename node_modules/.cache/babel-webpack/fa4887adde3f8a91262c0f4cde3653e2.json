{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, ViewChild, Input, Output, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport html2canvas from 'html2canvas';\nimport { of, from, Subject } from 'rxjs';\nimport { take, tap } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"rect\"];\nconst _c1 = [\"over\"];\nconst _c2 = [\"*\"];\nlet NgxCaptureService = /*#__PURE__*/(() => {\n  class NgxCaptureService {\n    getImage(screen, fullCapture, cropDimensions) {\n      let options = {\n        logging: false\n      };\n      if (!fullCapture && cropDimensions.width > 10 && cropDimensions.height > 10) {\n        options = Object.assign(Object.assign({}, options), cropDimensions);\n      } else if (!fullCapture) {\n        return of(null);\n      }\n      return from(html2canvas(screen, options).then(canv => {\n        const img = canv.toDataURL('image/png');\n        return img;\n      }, err => {\n        throw new Error(err);\n      }).catch(res => {\n        throw new Error(res);\n      }));\n    }\n    // TODO\n    downloadImage(img) {\n      // this.canvas.nativeElement.src = img;\n      // this.downloadLink.nativeElement.href = img;\n      // this.downloadLink.nativeElement.download = 'test.png';\n      // this.downloadLink.nativeElement.click();\n    }\n  }\n  NgxCaptureService.ɵfac = function NgxCaptureService_Factory(t) {\n    return new (t || NgxCaptureService)();\n  };\n  NgxCaptureService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function NgxCaptureService_Factory() {\n      return new NgxCaptureService();\n    },\n    token: NgxCaptureService,\n    providedIn: \"root\"\n  });\n  return NgxCaptureService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxCaptureComponent = /*#__PURE__*/(() => {\n  class NgxCaptureComponent {\n    constructor(captureService) {\n      this.captureService = captureService;\n      this.resultImage = new EventEmitter();\n      this.isDrawing = false;\n      this.mouseStart = {\n        x: 0,\n        y: 0\n      };\n      this.cropDimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      this.destroy$ = new Subject();\n    }\n    ngOnInit() {\n      setTimeout(() => {\n        this.rect = this.rectangle.nativeElement;\n        this.captureZone = this.overlay.nativeElement;\n        if (!this.captureZone) {\n          console.warn('\"captureZone\" is not set');\n          return;\n        }\n        this.captureZone.onmousedown = e => this.startCapture(e);\n        this.captureZone.onmousemove = e => this.drawRect(e);\n        this.captureZone.onmouseup = () => this.endCapture();\n      }, 2000);\n    }\n    startCapture(e) {\n      const mouse = this.setMousePosition(e, true);\n      this.isDrawing = true;\n      this.cropDimensions = {\n        x: mouse.x,\n        y: mouse.y,\n        width: 0,\n        height: 0\n      };\n      this.captureZone.style.cursor = 'crosshair';\n    }\n    drawRect(e) {\n      if (this.isDrawing) {\n        const mouse = this.setMousePosition(e, false);\n        this.cropDimensions = {\n          x: mouse.x - this.mouseStart.x < 0 ? mouse.x : this.mouseStart.x,\n          y: mouse.y - this.mouseStart.y < 0 ? mouse.y : this.mouseStart.y,\n          width: Math.abs(mouse.x - this.mouseStart.x),\n          height: Math.abs(mouse.y - this.mouseStart.y)\n        };\n        this.setRectangle();\n      }\n    }\n    setMousePosition(e, isStart = false) {\n      const ev = e || window.event; // Moz || IE\n      const mouse = {\n        x: 0,\n        y: 0\n      };\n      if (ev.pageX) {\n        // Moz\n        mouse.x = ev.clientX;\n        mouse.y = ev.clientY;\n      } else if (ev.clientX) {\n        // IE\n        mouse.x = ev.clientX + document.body.scrollLeft;\n        mouse.y = ev.clientY + document.body.scrollTop;\n      }\n      if (isStart) {\n        this.mouseStart.x = mouse.x;\n        this.mouseStart.y = mouse.y;\n      }\n      return mouse;\n    }\n    endCapture() {\n      this.captureZone.style.cursor = 'default';\n      this.isDrawing = false;\n      this.captureService.getImage(this.target, false, Object.assign(Object.assign({}, this.cropDimensions), {\n        x: this.cropDimensions.x + window.scrollX,\n        y: this.cropDimensions.y + window.scrollY\n      })).pipe(take(1), tap(img => {\n        this.resultImage.emit(img);\n      })).subscribe();\n      this.cropDimensions = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      this.setRectangle();\n    }\n    setRectangle() {\n      this.rect.style.left = this.cropDimensions.x + 'px';\n      this.rect.style.top = this.cropDimensions.y + 'px';\n      this.rect.style.width = this.cropDimensions.width + 'px';\n      this.rect.style.height = this.cropDimensions.height + 'px';\n    }\n  }\n  NgxCaptureComponent.ɵfac = function NgxCaptureComponent_Factory(t) {\n    return new (t || NgxCaptureComponent)(ɵngcc0.ɵɵdirectiveInject(NgxCaptureService));\n  };\n  NgxCaptureComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxCaptureComponent,\n    selectors: [[\"ngx-capture\"]],\n    viewQuery: function NgxCaptureComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rectangle = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlay = _t.first);\n      }\n    },\n    inputs: {\n      target: \"target\"\n    },\n    outputs: {\n      resultImage: \"resultImage\"\n    },\n    ngContentSelectors: _c2,\n    decls: 5,\n    vars: 0,\n    consts: [[1, \"overlay\"], [\"over\", \"\"], [1, \"rectangle\"], [\"rect\", \"\"]],\n    template: function NgxCaptureComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 0, 1);\n        ɵngcc0.ɵɵelement(3, \"div\", 2, 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    styles: [\".overlay[_ngcontent-%COMP%]{top:0px;left:0px;position:fixed;width:100vw;height:100vh}.rectangle[_ngcontent-%COMP%]{border:1px solid #ff0000;position:absolute}\"]\n  });\n  return NgxCaptureComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxCaptureModule = /*#__PURE__*/(() => {\n  class NgxCaptureModule {}\n  NgxCaptureModule.ɵfac = function NgxCaptureModule_Factory(t) {\n    return new (t || NgxCaptureModule)();\n  };\n  NgxCaptureModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxCaptureModule\n  });\n  NgxCaptureModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return NgxCaptureModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxCaptureModule, {\n    declarations: [NgxCaptureComponent],\n    exports: [NgxCaptureComponent]\n  });\n})();\n\n/*\r\n * Public API Surface of ngx-capture\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { NgxCaptureComponent, NgxCaptureModule, NgxCaptureService };\n\n//# sourceMappingURL=ngx-capture.js.map","map":null,"metadata":{},"sourceType":"module"}
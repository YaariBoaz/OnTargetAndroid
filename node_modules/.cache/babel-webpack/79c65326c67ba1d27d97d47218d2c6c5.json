{"ast":null,"code":"import { __read, __values } from \"tslib\";\nimport { eventToSentryRequest, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, initAPIDetails, sessionToSentryRequest } from '@sentry/core';\nimport { createClientReportEnvelope, dsnToString, eventStatusFromHttpCode, getGlobalObject, isDebugBuild, logger, makePromiseBuffer, parseRetryAfterHeader, serializeEnvelope } from '@sentry/utils';\nimport { sendReport } from './utils';\nfunction requestTypeToCategory(ty) {\n  var tyStr = ty;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\nvar global = getGlobalObject();\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */function () {\n  function BaseTransport(options) {\n    var _this = this;\n    this.options = options;\n    /** A simple buffer holding all requests. */\n    this._buffer = makePromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n    this._rateLimits = {};\n    this._outcomes = {};\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', function () {\n        if (global.document.visibilityState === 'hidden') {\n          _this._flushOutcomes();\n        }\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendEvent = function (event) {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendSession = function (session) {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.recordLostEvent = function (reason, category) {\n    var _a;\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    var key = requestTypeToCategory(category) + \":\" + reason;\n    logger.log(\"Adding outcome: \" + key);\n    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;\n  };\n  /**\n   * Send outcomes as an envelope\n   */\n  BaseTransport.prototype._flushOutcomes = function () {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    var outcomes = this._outcomes;\n    this._outcomes = {};\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      logger.log('No outcomes to flush');\n      return;\n    }\n    logger.log(\"Flushing outcomes:\\n\" + JSON.stringify(outcomes, null, 2));\n    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n    var discardedEvents = Object.keys(outcomes).map(function (key) {\n      var _a = __read(key.split(':'), 2),\n        category = _a[0],\n        reason = _a[1];\n      return {\n        reason: reason,\n        category: category,\n        quantity: outcomes[key]\n      };\n      // TODO: Improve types on discarded_events to get rid of cast\n    });\n\n    var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      logger.error(e);\n    }\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n      response = _a.response,\n      headers = _a.headers,\n      resolve = _a.resolve,\n      reject = _a.reject;\n    var status = eventStatusFromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n    var limited = this._handleRateLimit(headers);\n    if (limited && isDebugBuild()) {\n      logger.warn(\"Too many \" + requestType + \" requests, backing off until: \" + this._disabledUntil(requestType));\n    }\n    if (status === 'success') {\n      resolve({\n        status: status\n      });\n      return;\n    }\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  BaseTransport.prototype._disabledUntil = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return this._rateLimits[category] || this._rateLimits.all;\n  };\n  /**\n   * Checks if a category is rate limited\n   */\n  BaseTransport.prototype._isRateLimited = function (requestType) {\n    return this._disabledUntil(requestType) > new Date(Date.now());\n  };\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  BaseTransport.prototype._handleRateLimit = function (headers) {\n    var e_1, _a, e_2, _b;\n    var now = Date.now();\n    var rlHeader = headers['x-sentry-rate-limits'];\n    var raHeader = headers['retry-after'];\n    if (rlHeader) {\n      try {\n        // rate limit headers are of the form\n        //     <header>,<header>,..\n        // where each <header> is of the form\n        //     <retry_after>: <categories>: <scope>: <reason_code>\n        // where\n        //     <retry_after> is a delay in ms\n        //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n        //         <category>;<category>;...\n        //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n        //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n        for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var limit = _d.value;\n          var parameters = limit.split(':', 2);\n          var headerDelay = parseInt(parameters[0], 10);\n          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              this._rateLimits[category || 'all'] = new Date(now + delay);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n    return false;\n  };\n  return BaseTransport;\n}();\nexport { BaseTransport };\n//# sourceMappingURL=base.js.map","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\r\n * Responsive functionality module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObjectEvents } from \"../Base\";\nimport { List } from \"../utils/List\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { registry } from \"../Registry\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport * as $object from \"../utils/Object\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Responsive is responsible for overriding certain properties when conditions\r\n * are met.\r\n *\r\n * This class is used to dynamically apply and change certain chart properties\r\n * based on the current values of properties.\r\n *\r\n * Mainly, this is used with [[Sprite]]'s dimensional properties, like\r\n * `pixelWidth` and `pixelHeight`. However, it can be used to dynamically\r\n * change any property, based on any other property's value.\r\n *\r\n * A default responsive rules are disabled.\r\n *\r\n * To enable, set `enabled = false`. E.g.:\r\n *\r\n * ```TypeScript\r\n * chart.responsive.enabled = true;\r\n * ```\r\n * ```JavaScript\r\n * chart.responsive.enabled = true;\r\n * ```\r\n *\r\n * @see {@link IResponsiveEvents} for a list of available events\r\n * @see {@link IResponsiveAdapters} for a list of available Adapters\r\n * @todo Add default rules\r\n * @todo Watch for rule modification\r\n * @important\r\n */\nvar Responsive = /** @class */function (_super) {\n  __extends(Responsive, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Responsive() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * Holds a list of responsive rules organized by object type.\r\n     */\n    _this._rules = new List();\n    /**\r\n     * Holds the list of the default responsive rules.\r\n     * @deprecated\r\n     */\n    //protected _defaultRules = new List<IResponsiveRule>();\n    /**\r\n     * Holds the list of currently applied rules.\r\n     */\n    _this._appliedRules = {};\n    /**\r\n     * Used to keep track of objects that have rules applied at the moment.\r\n     */\n    _this._appliedTargets = [];\n    /**\r\n     * Use default rules in addition to the user-defined ones?\r\n     */\n    _this._useDefault = true;\n    /**\r\n     * Adapter.\r\n     */\n    _this.adapter = new Adapter(_this);\n    /**\r\n     * Indicates of responsive rules application is enabled.\r\n     */\n    _this._enabled = false;\n    /**\r\n     * Holds disposers for all events added by this class.\r\n     */\n    _this._responsiveDisposers = [];\n    /**\r\n     * Collection of objects and state ids that do not have any properties set.\r\n     */\n    _this._noStates = [];\n    _this.className = \"Responsive\";\n    // Set up rules list events\n    _this.rules.events.on(\"inserted\", function () {\n      _this.checkRules();\n    }, true);\n    _this.rules.events.on(\"removed\", function () {\n      _this.checkRules();\n    }, true);\n    _this._disposers.push(_this.rules.events);\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(Responsive.prototype, \"component\", {\n    /**\r\n     * @return Target object\r\n     */\n    get: function () {\n      return this._component;\n    },\n    /**\r\n     * A target object that responsive rules will need to be applied to.\r\n     *\r\n     * @param value  Target object\r\n     */\n    set: function (value) {\n      var _this = this;\n      // Check if it's the same\n      if (value == this._component) {\n        return;\n      }\n      // Check if we already have a set up component and remove its events\n      this.disposeResponsiveHandlers();\n      // Set\n      this._component = value;\n      // Set up resize monitoring events\n      this._responsiveDisposers.push($type.getValue(this.component).events.on(\"sizechanged\", function () {\n        _this.checkRules();\n      }, this));\n      this._responsiveDisposers.push($type.getValue(this.component).events.once(\"datavalidated\", function () {\n        if (_this._component.isReady()) {\n          _this.checkRules(true);\n        }\n      }, this));\n      // Enable resoponsive\n      this.enabled = true;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Responsive.prototype, \"enabled\", {\n    /**\r\n     * @return Apply responsive rules?\r\n     */\n    get: function () {\n      return this.adapter.apply(\"enabled\", this._enabled);\n    },\n    /**\r\n     * Should responsive rules be checked against and applied?\r\n     *\r\n     * @default false\r\n     * @param value  Apply responsive rules?\r\n     */\n    set: function (value) {\n      if (this._enabled != value) {\n        this._enabled = value;\n        // Run `applyRules` so that any currently applied rules can be reset\n        this.applyRules();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Responsive.prototype, \"useDefault\", {\n    /**\r\n     * @return Use default rules?\r\n     */\n    get: function () {\n      return this.adapter.apply(\"useDefault\", this._useDefault);\n    },\n    /**\r\n     * Should default responsive rules be applied in addition to user-defined\r\n     * ones.\r\n     *\r\n     * User-defined rules will take precedence over default rules whenever they\r\n     * produce conflicting settings.\r\n     *\r\n     * @default true\r\n     * @param value  Use default rules?\r\n     */\n    set: function (value) {\n      if (this._useDefault != value) {\n        this._useDefault = value;\n        // Run `applyRules` so that any currently applied rules can be reset\n        this.applyRules();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Responsive.prototype, \"rules\", {\n    /**\r\n     * @return User-defined rules\r\n     */\n    get: function () {\n      return this.adapter.apply(\"rules\", this._rules);\n    },\n    /**\r\n     * User-defined responsive rules.\r\n     *\r\n     * User-defined rules will take precedence over default rules whenever they\r\n     * produce conflicting settings.\r\n     *\r\n     * Use `allRules` to get all applicable rules including default and\r\n     * user-defined ones.\r\n     *\r\n     * @param value  User-defined rules\r\n     */\n    set: function (value) {\n      this._rules = value;\n      this._enabled = true;\n      this.applyRules();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Responsive.prototype, \"defaultRules\", {\n    /**\r\n     * Default responsive rules.\r\n     *\r\n     * @readonly\r\n     * @return List of responsive rules\r\n     */\n    get: function () {\n      return this.adapter.apply(\"defaultRules\", defaultRules);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Responsive.prototype, \"allRules\", {\n    /**\r\n     * Returns all rules: default rules (if not disabled) combined with\r\n     * user-defined ones.\r\n     *\r\n     * @readonly\r\n     * @return List of all applicable rules\r\n     */\n    get: function () {\n      // Create empty list\n      var rules = new List();\n      // Add default rules if not disabled\n      // A code, requesting `allRules` must ensure loading of default rules\n      // by calling `loadDefaultRules()`\n      if (this.useDefault) {\n        rules.copyFrom(this.defaultRules);\n      }\n      // Add user-defined ones\n      rules.copyFrom(this.rules);\n      return this.adapter.apply(\"allRules\", rules);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks if rule by the particular id currently applied.\r\n   *\r\n   * @param ruleId  Rule ID\r\n   * @return Is currently applied?\r\n   */\n  Responsive.prototype.isApplied = function (ruleId) {\n    var rule = this._appliedRules[ruleId];\n    return $type.hasValue(rule) ? rule : false;\n  };\n  /**\r\n   * Checks which responsive rules currently satisfy their conditions and\r\n   * should be applied, or unapplied.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Responsive.prototype.checkRules = function (force) {\n    var _this = this;\n    if (force === void 0) {\n      force = false;\n    }\n    // Check if there are any rules\n    var rules = this.allRules;\n    if (!rules || rules.length == 0) {\n      return;\n    }\n    // Init a list of rules to be applied\n    var rulesChanged = false;\n    var component = $type.getValue(this.component);\n    // Do not perform rule application of target has no size\n    if (component.pixelWidth == 0 || component.pixelHeight == 0) {\n      return;\n    }\n    // Check which rules match\n    $iter.each(rules.iterator(), function (rule) {\n      // Check if rule has an id\n      if (!rule.id) {\n        rule.id = registry.getUniqueId();\n      }\n      // Init indicator if this rule should be applied\n      var apply = rule.relevant(component);\n      // Let's check if this rule needs to be applied\n      if (apply && !_this.isApplied(rule.id) || !apply && _this.isApplied(rule.id)) {\n        rulesChanged = true;\n      }\n      _this._appliedRules[rule.id] = apply;\n    });\n    if (force) {\n      rulesChanged = true;\n    }\n    // Check if we need to re-apply the rules\n    if (rulesChanged) {\n      if (!this.component.isReady()) {\n        // The chart is not yet ready (built)\n        // We will hide the chart and delay application of rules\n        // until \"ready\" event kicks in\n        //component.hide(0);\n        component.hidden = true;\n        component.events.once(\"ready\", function (ev) {\n          ev.target.show(0);\n          _this._applyRules();\n        });\n        return;\n      }\n      this.dispatchImmediately(\"ruleschanged\");\n      this._applyRules();\n    }\n  };\n  Responsive.prototype._applyRules = function () {\n    var _this = this;\n    if (this._timeout) {\n      this._timeout.dispose();\n    }\n    this._timeout = this.setTimeout(function () {\n      _this.applyRules();\n    }, 10);\n  };\n  /**\r\n   * Applies current rules to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param target Target object\r\n   * @todo Better type check\r\n   */\n  Responsive.prototype.applyRules = function (target) {\n    var _this = this;\n    // If no target supplied, we assume the top-level element\n    var newTarget = $type.hasValue(target) ? target : $type.getValue(this.component);\n    // Check each rule\n    var defaultStateApplied = false;\n    if (this.enabled) {\n      var isApplied_1 = false;\n      $iter.each(this.allRules.iterator(), function (rule) {\n        // Get relevant state\n        var state = _this.getState(rule, newTarget);\n        // If there's a state, it means it needs to be applied\n        if (state) {\n          // Check if default state was already applied to this element.\n          // We don't want to go resetting default states to ALL element,\n          // if they don't have responsive states.\n          if (!defaultStateApplied) {\n            // Nope, reset states (instantly).\n            if ($array.indexOf(_this._appliedTargets, newTarget.uid) !== -1) {\n              // But only if this element has any rules applied, otherwise no\n              // point in setting current state\n              newTarget.setState(_this.getDefaultState(newTarget), 0);\n            }\n            defaultStateApplied = true;\n          }\n          // Is this rule currently applied?\n          if (_this.isApplied($type.getValue(rule.id))) {\n            // Yes. Apply the responsive state\n            state.transitionDuration = 0;\n            _this.setTargetState(newTarget, state);\n            _this.dispatchImmediately(\"ruleapplied\", {\n              rule: rule\n            });\n            isApplied_1 = true;\n          }\n        }\n      });\n      if (isApplied_1) {\n        $array.replace(this._appliedTargets, newTarget.uid);\n      } else {\n        $array.remove(this._appliedTargets, newTarget.uid);\n      }\n    }\n    // Apply rules to the children\n    if (newTarget.children) {\n      $iter.each(newTarget.children.iterator(), function (child) {\n        _this.applyRules(child);\n      });\n    }\n  };\n  /**\r\n   * Returns a relative state for the rule/target, or `undefined` if no state is\r\n   * needed.\r\n   *\r\n   * @param rule    [description]\r\n   * @param target  [description]\r\n   * @return [description]\r\n   */\n  Responsive.prototype.getState = function (rule, target) {\n    var stateId = \"responsive-\" + rule.id;\n    var tmpId = target.uid + \"_\" + stateId;\n    if ($array.indexOf(this._noStates, tmpId) !== -1) {\n      return;\n    } else if (!target.states.hasKey(stateId)) {\n      var state = rule.state(target, stateId);\n      if (!state) {\n        this._noStates.push(tmpId);\n      }\n      return state;\n    } else {\n      return target.states.getKey(stateId);\n    }\n  };\n  /**\r\n   * Creates and returns default responsive rule for the target.\r\n   *\r\n   * This rule will be used to \"reset\" to non-responsive values.\r\n   * @param   target  Target Sprite\r\n   * @return          State\r\n   */\n  Responsive.prototype.getDefaultState = function (target) {\n    if (target.states.hasKey(\"responsive-default\")) {\n      return target.states.getKey(\"responsive-default\");\n    }\n    return target.states.create(\"responsive-default\");\n  };\n  /**\r\n   * Sets state on the target element and updates default state with the\r\n   * overwritten values if needed.\r\n   *\r\n   * @param  target  Target\r\n   * @param  state   State\r\n   */\n  Responsive.prototype.setTargetState = function (target, state) {\n    var _this = this;\n    // Update default state\n    var defaultState = this.getDefaultState(target);\n    $object.each(state.properties, function (key, val) {\n      if (!$type.hasValue(defaultState.properties[key])) {\n        defaultState.properties[key] = _this.getValue(target, key);\n      }\n    });\n    target.setState(state);\n  };\n  /**\r\n   * Gets a value from an element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param target    Target object\r\n   * @param property  Property\r\n   * @return Property value\r\n   */\n  Responsive.prototype.getValue = function (target, property) {\n    // This is a bit hacky, first we check if the property exist.\n    // If it doesn't we try accessing target's property directly\n    var value = target.getPropertyValue(property);\n    if (!$type.hasValue(value) && $type.hasValue(target[property])) {\n      value = target[property];\n    }\n    return value;\n  };\n  /**\r\n   * Disposes the object.\r\n   */\n  Responsive.prototype.dispose = function () {\n    this.disposeResponsiveHandlers();\n    _super.prototype.dispose.call(this);\n  };\n  /**\r\n   * Disposes all event handlers.\r\n   */\n  Responsive.prototype.disposeResponsiveHandlers = function () {\n    var disposer = this._responsiveDisposers.pop();\n    while (disposer) {\n      disposer.dispose();\n      disposer = this._responsiveDisposers.pop();\n    }\n  };\n  return Responsive;\n}(BaseObjectEvents);\nexport { Responsive };\n/**\r\n * [defaultRules description]\r\n *\r\n * @todo description\r\n */\nexport var defaultRules = new List();\ndefaultRules.events.on(\"inserted\", function (ev) {\n  ev.newValue.id = registry.getUniqueId();\n});\n/**\r\n *\r\n * @todo description\r\n */\nvar ResponsiveBreakpoints = /** @class */function () {\n  function ResponsiveBreakpoints() {}\n  // Breakpoint functions (for use in `relevant` clause of the responsive rules)\n  ResponsiveBreakpoints.widthXXS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XXS;\n  };\n  ResponsiveBreakpoints.widthXS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XS;\n  };\n  ResponsiveBreakpoints.widthS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.S;\n  };\n  ResponsiveBreakpoints.widthM = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.M;\n  };\n  ResponsiveBreakpoints.widthL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.L;\n  };\n  ResponsiveBreakpoints.widthXL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XL;\n  };\n  ResponsiveBreakpoints.widthXXL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XXL;\n  };\n  ResponsiveBreakpoints.heightXXS = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.XXS;\n  };\n  ResponsiveBreakpoints.heightXS = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.XS;\n  };\n  ResponsiveBreakpoints.heightS = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.S;\n  };\n  ResponsiveBreakpoints.heightM = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.M;\n  };\n  ResponsiveBreakpoints.heightL = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.L;\n  };\n  ResponsiveBreakpoints.heightXL = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.XL;\n  };\n  ResponsiveBreakpoints.heightXXL = function (container) {\n    return container.pixelHeight <= ResponsiveBreakpoints.XXL;\n  };\n  ResponsiveBreakpoints.isXXS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XXS && container.pixelHeight <= ResponsiveBreakpoints.XXS;\n  };\n  ResponsiveBreakpoints.isXS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XS && container.pixelHeight <= ResponsiveBreakpoints.XS;\n  };\n  ResponsiveBreakpoints.isS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.S && container.pixelHeight <= ResponsiveBreakpoints.S;\n  };\n  ResponsiveBreakpoints.isM = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.M && container.pixelHeight <= ResponsiveBreakpoints.M;\n  };\n  ResponsiveBreakpoints.isL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.L && container.pixelHeight <= ResponsiveBreakpoints.L;\n  };\n  ResponsiveBreakpoints.isXL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XL && container.pixelHeight <= ResponsiveBreakpoints.XL;\n  };\n  ResponsiveBreakpoints.isXXL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XXL && container.pixelHeight <= ResponsiveBreakpoints.XXL;\n  };\n  ResponsiveBreakpoints.maybeXXS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XXS || container.pixelHeight <= ResponsiveBreakpoints.XXS;\n  };\n  ResponsiveBreakpoints.maybeXS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XS || container.pixelHeight <= ResponsiveBreakpoints.XS;\n  };\n  ResponsiveBreakpoints.maybeS = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.S || container.pixelHeight <= ResponsiveBreakpoints.S;\n  };\n  ResponsiveBreakpoints.maybeM = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.M || container.pixelHeight <= ResponsiveBreakpoints.M;\n  };\n  ResponsiveBreakpoints.maybeL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.L || container.pixelHeight <= ResponsiveBreakpoints.L;\n  };\n  ResponsiveBreakpoints.maybeXL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XL || container.pixelHeight <= ResponsiveBreakpoints.XL;\n  };\n  ResponsiveBreakpoints.maybeXXL = function (container) {\n    return container.pixelWidth <= ResponsiveBreakpoints.XXL || container.pixelHeight <= ResponsiveBreakpoints.XXL;\n  };\n  // Named pixel breakpoints\n  ResponsiveBreakpoints.XXS = 100;\n  ResponsiveBreakpoints.XS = 200;\n  ResponsiveBreakpoints.S = 300;\n  ResponsiveBreakpoints.M = 400;\n  ResponsiveBreakpoints.L = 600;\n  ResponsiveBreakpoints.XL = 800;\n  ResponsiveBreakpoints.XXL = 1000;\n  return ResponsiveBreakpoints;\n}();\nexport { ResponsiveBreakpoints };\n//# sourceMappingURL=Responsive.js.map","map":null,"metadata":{},"sourceType":"module"}
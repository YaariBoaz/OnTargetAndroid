{"version":3,"file":"index.d.ts","sources":["index.d.ts"],"names":[],"mappings":"AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AwesomeCordovaNativePlugin } from '@awesome-cordova-plugins/core';\nexport interface IAPProductOptions {\n    id: string;\n    alias?: string;\n    type: string;\n}\nexport interface IRefeshResult {\n    cancelled(fn: () => void): void;\n    failed(fn: () => void): void;\n    completed(fn: () => void): void;\n    finished(fn: () => void): void;\n}\nexport declare type IAPProducts = IAPProduct[] & {\n    /**\n     * Get product by ID\n     */\n    byId: {\n        [id: string]: IAPProduct;\n    };\n    /**\n     * Get product by alias\n     */\n    byAlias: {\n        [alias: string]: IAPProduct;\n    };\n    /**\n     * Remove all products (for testing only).\n     */\n    reset: () => {};\n};\nexport declare type IAPQueryCallback = ((product: IAPProduct) => void) | ((error: IAPError) => void);\nexport interface IAPProduct {\n    id: string;\n    alias?: string;\n    type: string;\n    state: string;\n    title: string;\n    description: string;\n    priceMicros: number;\n    price: string;\n    currency: string;\n    loaded: boolean;\n    valid: boolean;\n    canPurchase: boolean;\n    owned: boolean;\n    downloading?: boolean;\n    downloaded?: boolean;\n    lastRenewalDate?: Date;\n    expiryDate?: Date;\n    introPrice?: string;\n    introPriceMicros?: number;\n    introPriceNumberOfPeriods?: number;\n    introPriceSubscriptionPeriod?: string;\n    introPricePaymentMode?: string;\n    ineligibleForIntroPrice?: boolean;\n    billingPeriod?: number;\n    billingPeriodUnit?: string;\n    trialPeriod?: number;\n    trialPeriodUnit?: string;\n    additionalData?: any;\n    transaction?: PlayStoreReceipt | AppStoreReceipt;\n    /**\n     * Call `product.finish()` to confirm to the store that an approved order has been delivered.\n     *\n     * This will change the product state from `APPROVED` to `FINISHED` (see product life-cycle).\n     *\n     * As long as you keep the product in state `APPROVED`:\n     *\n     *  - the money may not be in your account (i.e. user isn't charged)\n     *  - you will receive the `approved` event each time the application starts,\n     *    where you should try again to finish the pending transaction.\n     *\n     * example use**\n     *\n     * ```js\n     * store.when(\"product.id\").approved(function(product){\n     *     // synchronous\n     *     app.unlockFeature();\n     *     product.finish();\n     * });\n     * ```\n     *\n     * ```js\n     * store.when(\"product.id\").approved(function(product){\n     *     // asynchronous\n     *     app.downloadFeature(function() {\n     *         product.finish();\n     *     });\n     * });\n     * ```\n     */\n    finish(): void;\n    /**\n     * Initiate purchase validation as defined by the `store.validator` attribute.\n     *\n     * return value**\n     *\n     * A Promise with the following methods:\n     *\n     *  - `done(function(product){})`\n     *    - called whether verification failed or succeeded.\n     *  - `expired(function(product){})`\n     *    - called if the purchase expired.\n     *  - `success(function(product, purchaseData){})`\n     *    - called if the purchase is valid and verified.\n     *    - `purchaseData` is the device dependent transaction details\n     *      returned by the validator, which you can most probably ignore.\n     *  - `error(function(err){})`\n     *    - validation failed, either because of expiry or communication\n     *      failure.\n     *    - `err` is a store.Error object, with a code expected to be\n     *      `store.ERR_PAYMENT_EXPIRED` or `store.ERR_VERIFICATION_FAILED`.\n     */\n    verify(): any;\n    set(key: string, value: any): void;\n    stateChanged(): void;\n    on(event: string, callback: Function): void;\n    once(event: string, callback: Function): void;\n    off(callback: Function): void;\n    trigger(action: string, args: any): void;\n}\nexport interface IAPProductEvents {\n    /** Called when product data is loaded from the store. */\n    loaded: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when any change occured to a product. */\n    updated: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when an order failed. The `err` parameter is an IAPError object. */\n    error: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when a product order is approved. */\n    approved: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when a non-consumable product or subscription is owned. */\n    owned: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when a product order is cancelled by the user. */\n    cancelled: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when an order is refunded by the user. */\n    refunded: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when product has just been registered. */\n    registered: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when the product details have been successfully loaded. */\n    valid: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when the product cannot be loaded from the store. */\n    invalid: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when an order has just been requested. */\n    requested: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when the purchase process has been initiated. */\n    initiated: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when the purchase process has completed. */\n    finished: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when receipt validation successful. */\n    verified: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when receipt verification failed. */\n    unverified: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when validation find a subscription to be expired. */\n    expired: (callback: IAPQueryCallback) => IAPProductEvents;\n    /** Called when content download is started. */\n    downloading: (product: IAPProduct, progress: any, time_remaining: any) => IAPProductEvents;\n    /** Called when content download has successfully completed. */\n    downloaded: (callback: IAPQueryCallback) => IAPProductEvents;\n}\nexport declare type PlayStoreReceipt = {\n    id: string;\n    purchaseState: number;\n    purchaseToken: string;\n    receipt: string;\n    signature: string;\n    type: 'android-playstore';\n};\nexport declare type AppStoreReceipt = {\n    id: string;\n    appStoreReceipt: string;\n    original_transaction_id: string;\n    type: 'ios-appstore';\n};\n/**\n * @hidden\n */\nexport declare class IAPError {\n    code: number;\n    message: string;\n}\n/**\n * @name In App Purchase 2\n * @description\n * In-App Purchase on iOS, Android, Windows, macOS and XBox.\n *\n * ## Features\n *\n * |  | ios | android | win-8 | win-10/uwp | mac |\n * |--|--|--|--|--|--|\n * | consumables | ✅ | ✅ | ✅ | ✅ | ✅ |\n * | non consumables | ✅ | ✅ | ✅ | ✅ | ✅ |\n * | subscriptions | ✅ | ✅ | ✅ | ✅ | ✅ |\n * | restore purchases | ✅ | ✅ | ✅ | ✅ | ✅ |\n * | receipt validations | ✅ | ✅ |  | ✅ | ✅ |\n * | downloadable content | ✅ |   |   |   | ✅ |\n * | introductory prices | ✅ | ✅ |   | ✅ | ✅ |\n *\n * Supports:\n *\n *  - **iOS** version 7.0 or higher.\n *  - **Android** version 2.2 (API level 8) or higher\n *    - with Google Play client version 3.9.16 or higher\n *  - **Windows** Store/Phone 8.1 or higher\n *  - **Windows 10 Mobile**\n *  - **macOS** version 10\n *  - **Xbox One**\n *    - (and any platform supporting Microsoft's UWP)\n * @usage\n * ```typescript\n * import { InAppPurchase2 } from '@awesome-cordova-plugins/in-app-purchase-2/ngx';\n *\n * constructor(public platform: Platform, private store: InAppPurchase2) {\n *   platform.ready().then(() => {\n *    this.store.register({\n *      id: \"my_product_id\",\n *      type: this.store.NON_RENEWING_SUBSCRIPTION,\n *    });\n *    this.store.when(\"my_product_id\")\n *      .approved(p => p.verify())\n *      .verified(p => p.finish());\n *    this.store.refresh();\n *   });\n * }\n *\n * ...\n *\n * this.store.order(\"my_product_id\");\n *\n * ```\n *\n * ## Full example\n *\n * ```typescript\n *  // After platform ready\n *  this.store.verbosity = this.store.DEBUG;\n *  this.store.register({\n *    id: \"my_product_id\",\n *    type: this.store.PAID_SUBSCRIPTION,\n *  });\n *\n *  // Register event handlers for the specific product\n *  this.store.when(\"my_product_id\").registered( (product: IAPProduct) => {\n *    console.log('Registered: ' + JSON.stringify(product));\n *  });\n *\n *  // Updated\n *  this.store.when(\"my_product_id\").updated( (product: IAPProduct) => {\n *    console.log('Updated' + JSON.stringify(product));\n *  });\n *\n *  // User closed the native purchase dialog\n *  this.store.when(\"my_product_id\").cancelled( (product) => {\n *      console.error('Purchase was Cancelled');\n *  });\n *\n *  // Track all store errors\n *  this.store.error( (err) => {\n *    console.error('Store Error ' + JSON.stringify(err));\n *  });\n *\n *  // Run some code only when the store is ready to be used\n *  this.store.ready(() =>  {\n *    console.log('Store is ready');\n *    console.log('Products: ' + JSON.stringify(this.store.products));\n *    console.log(JSON.stringify(this.store.get(\"my_product_id\")));\n *  });\n *\n *  // Refresh the status of in-app products\n *  this.store.refresh();\n *\n *  ...\n *\n *  // To make a purchase\n *  this.store.order(\"my_product_id\");\n *\n * ```\n *\n * ## Philosophy\n *\n * The API is mostly events based. As a user of this plugin,\n * you will have to register listeners to changes happening to the products\n * you register.\n *\n * The core of the listening mechanism is the `when()` method. It allows you to\n * be notified of changes to one or a set of products using a query mechanism:\n * ```typescript\n *  this.store.when(\"product\").updated(refreshScreen); // match any product\n *  this.store.when(\"full_version\").owned(unlockApp); // match a specific product\n *  this.store.when(\"subscription\").approved(serverCheck); // match all subscriptions\n *  this.store.when(\"downloadable content\").downloaded(showContent);\n * ```\n *\n * The `updated` event is fired whenever one of the fields of a product is\n * changed (its `owned` status for instance).\n *\n * This event provides a generic way to track the statuses of your purchases,\n * to unlock features when needed and to refresh your views accordingly.\n *\n * ## Registering products\n *\n * The store needs to know the type and identifiers of your products before you\n * can use them in your code.\n *\n * Use `store.register()` to define them before your first call to `store.refresh()`.\n *\n * Once registered, you can use `store.get()` to retrieve an `IAPProduct` object.\n *\n * ```typescript\n *  this.store.register({\n *    id: \"my_consumable1\",\n *    type: this.store.CONSUMABLE\n *  });\n *  ...\n *  const p = this.store.get(\"my_consumable1\");\n * ```\n *\n * The product `id` and `type` have to match products defined in your\n * Apple, Google or Microsoft developer consoles.\n *\n * Learn more about it [from the wiki](https://github.com/j3k0/cordova-plugin-purchase/wiki).\n *\n * ## Displaying products\n *\n * Right after you registered your products, nothing much is known about them\n * except their `id`, `type` and an optional `alias`.\n *\n * When you perform the initial call to `store.refresh()`, the platforms' server will\n * be contacted to load informations about the registered products: human\n * readable `title` and `description`, `price`, etc.\n *\n * This isn't an optional step, store owners require you\n * to display information about a product exactly as retrieved from their server: no\n * hard-coding of price and title allowed! This is also convenient for you\n * as you can change the price of your items knowing that it'll be reflected instantly\n * on your clients' devices.\n *\n * Note that the information may not be available when the first view that needs\n * them appears on screen. For you, the best option is to have your view monitor\n * changes made to the product.\n *\n * ## Purchasing\n *\n * #### initiate a purchase\n *\n * Purchases are initiated using the `store.order(\"some_product_id\")` method.\n *\n * The store will manage the internal purchase flow. It'll end:\n *\n *  - with an `approved` event. The product enters the `APPROVED` state.\n *  - with a `cancelled` event. The product gets back to the `VALID` state.\n *  - with an `error` event. The product gets back to the `VALID` state.\n *\n * See the product life-cycle section for details about product states.\n *\n * #### finish a purchase\n *\n * Once the transaction is approved, the product still isn't owned: the store needs\n * confirmation that the purchase was delivered before closing the transaction.\n *\n * To confirm delivery, you'll use the `product.finish()` method.\n *\n * #### example usage\n *\n * During initialization:\n * ```typescript\n * this.store.when(\"extra_chapter\").approved((product: IAPProduct) => {\n *   // download the feature\n *   app.downloadExtraChapter()\n *   .then(() => product.finish());\n * });\n * ```\n *\n * When the purchase button is clicked:\n * ```typescript\n * this.store.order(\"extra_chapter\");\n * ```\n *\n * #### un-finished purchases\n *\n * If your app wasn't able to deliver the content, `product.finish()` won't be called.\n *\n * Don't worry: the `approved` event will be re-triggered the next time you\n * call `store.refresh()`, which can very well be the next time\n * the application starts. Pending transactions are persistant.\n *\n * #### simple case\n *\n * In the most simple case, where:\n *\n *  - delivery of purchases is only local ;\n *  - you don't want (or need) to implement receipt validation ;\n *\n * You may just want to finish all purchases automatically. You can do it this way:\n * ```js\n * this.store.when(\"product\").approved((p: IAPProduct) => p.finish());\n * ```\n *\n * NOTE: the \"product\" query will match any purchases (see \"queries\" to learn more details about queries).\n *\n * ## Receipt validation\n *\n * To get the most up-to-date information about purchases (in case a purchase have been canceled, or a subscription renewed),\n * you should implement server side receipt validation.\n *\n * This also protects you against fake \"purchases\", made by some users using\n * \"free in-app purchase\" apps on their devices.\n *\n * When a purchase has been approved by the store, it's enriched with\n * transaction information (see `product.transaction` attribute).\n *\n * To verify a purchase you'll have to do three things:\n *\n *  - configure the validator.\n *  - call `product.verify()` from the `approved` event, before finishing the transaction.\n *  - finish the transaction when transaction is `verified`.\n *\n * Shameless Plug**: this is a feature many users struggle with, so as the author of this plugin, we can provide it to you as-a-service: https://billing.fovea.cc/\n * (which is free until you start making serious money)\n *\n * #### example using a validation URL\n *\n * ```js\n * this.store.validator = \"https://billing.fovea.cc/\";\n *\n * this.store.when(\"my stuff\")\n *   .approved((p: IAPProduct) => p.verify())\n *   .verified((p: IAPProduct) => p.finish());\n * ```\n *\n * ## Subscriptions\n *\n * For subscription, you MUST implement remote receipt validation.\n *\n * When the receipt validator returns a `store.PURCHASE_EXPIRED` error code, the subscription will\n * automatically loose its `owned` status.\n *\n * Typically, you'll enable and disable access to your content this way.\n * ```typescript\n * this.store.when(\"my_subcription\").updated((product: IAPProduct) => {\n *   if (product.owned)\n *     app.subscriberMode();\n *   else\n *     app.guestMode();\n * });\n * ```\n *\n * ## Product life-cycle\n *\n * A product will change state during the application execution.\n *\n * Find below a diagram of the different states a product can pass by.\n *\n * ```\n * REGISTERED +--> INVALID\n *            |\n *            +--> VALID +--> REQUESTED +--> INITIATED +-+\n *                                                       |\n *                 ^      +------------------------------+\n *                 |      |\n *                 |      |             +--> DOWNLOADING +--> DOWNLOADED +\n *                 |      |             |                                |\n *                 |      +--> APPROVED +--------------------------------+--> FINISHED +--> OWNED\n *                 |                                                             |\n *                 +-------------------------------------------------------------+\n * ```\n *\n * #### Notes\n *\n *  - When finished, a consumable product will get back to the `VALID` state, while other will enter the `OWNED` state.\n *  - Any error in the purchase process will bring a product back to the `VALID` state.\n *  - During application startup, products may go instantly from `REGISTERED` to `APPROVED` or `OWNED`, for example if they are purchased non-consumables or non-expired subscriptions.\n *  - Non-Renewing Subscriptions are iOS products only. Please see the [iOS Non Renewing Subscriptions documentation](https://github.com/j3k0/cordova-plugin-purchase/blob/master/doc/ios.md#non-renewing) for a detailed explanation.\n *\n * ## events\n *\n *  - `loaded(IAPProduct)`\n *    - Called when product data is loaded from the store.\n *  - `updated(IAPProduct)`\n *    - Called when any change occured to a product.\n *  - `error(err)`\n *    - Called when an order failed.\n *    - The `err` parameter is an error object\n *  - `approved(IAPProduct)`\n *    - Called when a product order is approved.\n *  - `owned(IAPProduct)`\n *    - Called when a non-consumable product or subscription is owned.\n *  - `cancelled(IAPProduct)`\n *    - Called when a product order is cancelled by the user.\n *  - `refunded(IAPProduct)`\n *    - Called when an order is refunded by the user.\n *  - Actually, all other product states have their promise\n *    - `registered`, `valid`, `invalid`, `requested`,\n *      `initiated` and `finished`\n *  - `verified(IAPProduct)`\n *    - Called when receipt validation successful\n *  - `unverified(IAPProduct)`\n *    - Called when receipt verification failed\n *  - `expired(IAPProduct)`\n *    - Called when validation find a subscription to be expired\n *  - `downloading(IAPProduct, progress, time_remaining)`\n *    - Called when content download is started\n *  - `downloaded(IAPProduct)`\n *    - Called when content download has successfully completed\n *\n * ## Learn More\n *\n *  - [GitHub](https://github.com/j3k0/cordova-plugin-purchase)\n *  - [GitBook](https://purchase.cordova.fovea.cc/)\n *  - [Wiki](https://github.com/j3k0/cordova-plugin-purchase/wiki)\n *  - [API reference](https://github.com/j3k0/cordova-plugin-purchase/blob/master/doc/api.md)\n *\n * ## Technical Support or Questions\n *\n * If you have questions or need help integrating In-App Purchase, [Open an Issue on GitHub](https://github.com/j3k0/cordova-plugin-purchase/issues) or email us at _support@fovea.cc_.\n *\n * @interfaces\n * IAPProduct\n * IAPProductOptions\n * IAPProductEvents\n * ```\n */\nexport declare class InAppPurchase2 extends AwesomeCordovaNativePlugin {\n    QUIET: number;\n    ERROR: number;\n    WARNING: number;\n    INFO: number;\n    DEBUG: number;\n    /**\n     * Debug level. Use QUIET, ERROR, WARNING, INFO or DEBUG constants\n     */\n    verbosity: number;\n    /**\n     * Set to true to clear the transaction queue. Not recommended for production.\n     * https://github.com/j3k0/cordova-plugin-purchase/blob/master/doc/api.md#random-tips\n     */\n    autoFinishTransactions: boolean;\n    /**\n     * Set to true to invoke the platform purchase sandbox. (Windows only)\n     */\n    sandbox: boolean;\n    /**\n     * Set to true to disable downloading of hosted content. (Apple only).\n     * Useful in development or when migrating your app away from Apple Hosted Content.\n     */\n    disableHostedContent: boolean;\n    FREE_SUBSCRIPTION: string;\n    PAID_SUBSCRIPTION: string;\n    NON_RENEWING_SUBSCRIPTION: string;\n    CONSUMABLE: string;\n    NON_CONSUMABLE: string;\n    ERR_SETUP: number;\n    ERR_LOAD: number;\n    ERR_PURCHASE: number;\n    ERR_LOAD_RECEIPTS: number;\n    ERR_CLIENT_INVALID: number;\n    ERR_PAYMENT_CANCELLED: number;\n    ERR_PAYMENT_INVALID: number;\n    ERR_PAYMENT_NOT_ALLOWED: number;\n    ERR_UNKNOWN: number;\n    ERR_REFRESH_RECEIPTS: number;\n    ERR_INVALID_PRODUCT_ID: number;\n    ERR_FINISH: number;\n    ERR_COMMUNICATION: number;\n    ERR_SUBSCRIPTIONS_NOT_AVAILABLE: number;\n    ERR_MISSING_TOKEN: number;\n    ERR_VERIFICATION_FAILED: number;\n    ERR_BAD_RESPONSE: number;\n    ERR_REFRESH: number;\n    ERR_PAYMENT_EXPIRED: number;\n    ERR_DOWNLOAD: number;\n    ERR_SUBSCRIPTION_UPDATE_NOT_AVAILABLE: number;\n    REGISTERED: string;\n    INVALID: string;\n    VALID: string;\n    REQUESTED: string;\n    INITIATED: string;\n    APPROVED: string;\n    FINISHED: string;\n    OWNED: string;\n    DOWNLOADING: string;\n    DOWNLOADED: string;\n    INVALID_PAYLOAD: number;\n    CONNECTION_FAILED: number;\n    PURCHASE_EXPIRED: number;\n    PURCHASE_CONSUMED: number;\n    INTERNAL_ERROR: number;\n    NEED_MORE_DATA: number;\n    products: IAPProducts;\n    validator: string | ((url: string | IAPProduct, callback: Function) => void) | {\n        url: string;\n        headers?: {\n            [token: string]: string;\n        };\n    };\n    applicationUsername: string | (() => string);\n    getApplicationUsername(): string;\n    log: {\n        error: (message: string) => void;\n        warn: (message: string) => void;\n        info: (message: string) => void;\n        debug: (message: string) => void;\n    };\n    /**\n     * Get product by id or alias\n     *\n     * @param idOrAlias\n     */\n    get(idOrAlias: string): IAPProduct;\n    /**\n     * Register error handler\n     *\n     * @param onError {Function} function to call on error\n     */\n    error(onError: Function): void;\n    /**\n     * Add or register a product\n     *\n     * @param product {IAPProductOptions}\n     */\n    register(product: IAPProductOptions | IAPProductOptions[]): void;\n    /**\n     *\n     * @param query\n     * @param event\n     * @param callback\n     * @returns {IAPProductEvents}\n     */\n    when(query: string | IAPProduct, event?: string, callback?: IAPQueryCallback): IAPProductEvents;\n    /**\n     * Identical to `when`, but the callback will be called only once. After being called, the callback will be unregistered.\n     *\n     * @param query {string | IAPProduct}\n     * @param [event] {event}\n     * @param [callback] {IAPQueryCallback}\n     * @returns {IAPProductEvents}\n     */\n    once(query: string | IAPProduct, event?: string, callback?: IAPQueryCallback): IAPProductEvents;\n    /**\n     * Unregister a callback. Works for callbacks registered with ready, when, once and error.\n     *\n     * @param callback {Function}\n     */\n    off(callback: Function): void;\n    /**\n     * Initiate the purchase of a product.\n     *\n     * The `product` argument can be either:\n     *\n     *  - the `IAPProduct` object\n     *  - the product `id`\n     *  - the product `alias`\n     *\n     * The `additionalData` argument is an optional object with attributes:\n     *  - `oldPurchasedSkus`: a string array with the old subscription to upgrade/downgrade on Android. See: [android developer](https://developer.android.com/google/play/billing/billing_reference.html#upgrade-getBuyIntentToReplaceSkus) for more info\n     *  - `developerPayload`: string representing the developer payload as described in [billing best practices](https://developer.android.com/google/play/billing/billing_best_practices.html)\n     *  - `applicationUsername`: the identifier of the user in your application.\n     *\n     * See the \"Purchasing section\" to learn more about the purchase process.\n     *\n     * return value**\n     *\n     * `store.order()` returns a Promise with the following methods:\n     *\n     *  - `then` - called when the order was successfully initiated.\n     *  - `error` - called if the order couldn't be initiated.\n     *\n     * @param product\n     * @param additionalData\n     */\n    order(product: string | IAPProduct, additionalData?: any): {\n        then: Function;\n        error: Function;\n    };\n    ready(callback: Function): void;\n    /**\n     * After you're done registering your store's product and events handlers,\n     * time to call `store.refresh()`.\n     *\n     * This will initiate all the complex behind-the-scene work, to load product\n     * data from the servers and restore whatever already have been\n     * purchased by the user.\n     *\n     * Note that you can call this method again later during the application\n     * execution to re-trigger all that hard-work. It's kind of expensive in term of\n     * processing, so you'd better consider it twice.\n     *\n     * One good way of doing it is to add a \"Refresh Purchases\" button in your\n     * applications settings. This way, if delivery of a purchase failed or\n     * if a user wants to restore purchases he made from another device, he'll\n     * have a way to do just that.\n     *\n     * example usage**\n     *\n     * ```typescript\n     *    // ...\n     *    // register products and events handlers here\n     *    // ...\n     *    //\n     *    // then and only then, call refresh.\n     *    this.store.refresh();\n     * ```\n     *\n     * restore purchases**\n     *\n     * Add a \"Refresh Purchases\" button to call the `store.refresh()` method, like:\n     *\n     * `<button onclick=\"<pseudo_code>this.store.refresh()</pseudo_code>\">Restore Purchases</button>`\n     *\n     * To make the restore purchases work as expected, please make sure that\n     * the \"approved\" event listener had be registered properly,\n     * and in the callback `product.finish()` should be called.\n     */\n    refresh(): IRefeshResult;\n    /** Lightweight method like refresh but do not relogin user */\n    update(): void;\n    /** Opens the Manage Subscription page (AppStore, Play, Microsoft, ...). */\n    manageSubscriptions(): void;\n    /** Opens the Code Redemption Sheet on iOS. (AppStore). */\n    redeem(): void;\n    /** Opens the Manage Billing page (AppStore, Play, Microsoft, ...), where the user can update his/her payment methods. */\n    manageBilling(): void;\n    /** Open the subscription price change notification workflow. (Play) See: https://developer.android.com/google/play/billing/subscriptions#price-change-communicate */\n    launchPriceChangeConfirmationFlow(productId: string, callback: (status: 'OK' | 'UnknownProduct' | 'UserCanceled') => void): void;\n}\n"]}